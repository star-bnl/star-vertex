\documentclass[11pt,a4paper]{article}
\usepackage{a4,graphicx,color}
\usepackage{footnpag,array}
\usepackage{fancyhdr,fancybox}
\usepackage{amsmath}
\usepackage{epsfig}
%\usepackage{french}
% Ca fait chier de pas pouvoir utiliser ca : les captions ne sont plus en italique et ca marque "Figure 1:" [sans espace devant le chiffre] au lieu de "{\sc Fig.} 1 :". 'faut que je me redefinisse une commande "caption".

\oddsidemargin=-7mm
\textwidth=174mm
\addtolength{\headheight}{0.55cm}
\makeatletter
\def\@captype{figure}
\makeatother

\newenvironment{changemargin}[2]{\begin{list}{}{
\setlength{\topsep}{0pt}
\setlength{\leftmargin}{0pt}
\setlength{\rightmargin}{0pt}
\setlength{\listparindent}{\parindent}
\setlength{\itemindent}{\parindent}
\setlength{\parsep}{0pt plus 1pt}
\addtolength{\leftmargin}{#1}
\addtolength{\rightmargin}{#2}
}\item }{\end{list}}
\newcommand{\itemb}[1]{\setlength{\parindent}{-1cm}\begin{changemargin}{1cm}{0cm}#1\end{changemargin}\setlength{\parindent}{0cm}}

% Profondeur de \subsubsection = 3
\setcounter{tocdepth}{3}     % Dans la table des matieres
\setcounter{secnumdepth}{3}  % Avec un numero.

\begin{document}

\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markboth{#1}{}}
\lhead{V0Finder and XiFinder}
\rhead{\thesection\ - {\em \leftmark}}
%\renewcommand{\caption}[1]{\addtocounter{figure}{1}Figgg \thefigure : {#1}}  %Evidemment, ca n'est pas considere comme un caption ! Donc pour lui c;est juste du texte qu'il ajoute apres chaque figure (=> pas a la ligne, pas centre, et apparait pas dans la table des matieres).
\def\figurename{{\sc Fig.}} %C'est mieux, mais j'ai toujours pas d'espace entre le chiffre et les ":". C'est chose faite avec le truc qui suit :-))
\makeatletter
\renewcommand{\fnum@figure}{\figurename~\thefigure~}
\makeatother
%Reste le probleme du texte qui n'est pas automatiquement en italique.
%\newcommand{\mycaption}{\caption}
%\renewcommand{\caption}[1]{\mycaption{#1}}
%Ca va pas, c'est malheureusement recursif. Tant pis, je me redefinis un caption perso.
\newcommand{\mycaption}[1]{\caption[\hspace{-10pt}{#1}]{{\em {#1}.}}}
% Et j'en ai profite pour raccourcir l'espace dans la liste des figures (entre le numero et la legende), et pour gerer le point correctement (pas de point dans la liste des figures, mais un point a la fin des legendes sous les figures). Youpi, c'est cool LaTeX !  :-D

%\discretionary{Avant la coupure}{après}{s'il n'y en a pas}
%\discretionary{}{-}{}
%


%\newenvironment{maliste}
%{ \begin{list}
%        {$\bullet$}
%        {\setlength{\labelwidth}{30pt}
%         \setlength{\leftmargin}{35pt}
%         \setlength{\itemsep}{\parsep}}}
%{ \end{list} }
% Si on remplace itemsep par un nombre avec ou sans unite : ca chie.
% Si on remplace a la fois parsep  et itemsep : ca compile, mais aucun resultat (ca printe les valeurs sur le document, en fait).

\newenvironment{maliste}
{\vspace{-7pt}
 \begin{list}
 {$\bullet$}
 {\setlength{\labelwidth}{30pt}
 \setlength{\leftmargin}{35pt}
 \setlength{\itemsep}{-4pt}}}
{\end{list}
 \vspace{-6pt}}







%\parindent40pt
%
%\begin{center}
%
%~
%
%\thispagestyle{empty}
%
%\vspace{8cm}
%
%{\Huge\bf XiFinder and V0Finder documentation}
%
%\end{center}

%\begin{picture}(21cm,29.7cm)(0cm,0cm)
%\put(5cm,5cm){\circle(3cm)}
%\end{picture}

\thispagestyle{empty}
\unitlength 1mm
\begin{picture}(200,220)(20,10)
%\put(5,0){\vector(1,0){190}}
%\put(5,0){\vector(0,1){230}}
\linethickness{1mm}
%\put(5,0){\framebox(190,250)
%{\vspace{2cm}\\
%{\Huge\bf XiFinder and V0Finder documentation}\\
%\vspace{1cm}\\
%{\tt StRoot/StSecondaryVertexMaker/}\\
%\vspace{1cm}\\
%\hfill {\small --- Julien Faivre}}
%}
%Ca marche pas, ca met rien a la ligne ; laisser une ligne vide non plus.
%\put(5,0){\framebox(190,250){~\vspace{-3cm}\Huge\bf XiFinder and V0Finder documentation}}
%Marche pas du tout...
\put(5,0){\framebox(190,250){}}
\linethickness{1pt}
\put(6,1){\framebox(188,248){}}
\put(5,140){\makebox(190,50){\Huge\bf XiFinder and V0Finder documentation}}
\put(40,120){\makebox(100,50)[l]{\Large\tt StRoot/StSecondaryVertexMaker/ :}}
\put(70,115){\makebox(100,50)[l]{\large\tt StV0FinderMaker.cxx}}
\put(70,110){\makebox(100,50)[l]{\large\tt StV0FinderMaker.h}}
\put(70,105){\makebox(100,50)[l]{\large\tt StXiFinderMaker.cxx}}
\put(70,100){\makebox(100,50)[l]{\large\tt StXiFinderMaker.h}}
\put(40,90){\makebox(100,50)[l]{\Large\tt StRoot/StSecondaryVertexMaker/doc/ :}}
\put(70,85){\makebox(100,50)[l]{\large\tt docXiFinder.tex}}

\put(5,50){\makebox(190,50){\hfill --- Julien Faivre\hspace{40pt}}}
\put(5,45){\makebox(190,50){\hfill Strangeness group\hspace{40pt}}}
\put(5,40){\makebox(190,50){\tt\small\hfill julien.faivre@ires.in2p3.fr\hspace{40pt}}}
\end{picture}







\newpage


\section*{}
\addcontentsline{toc}{section}{Table of contents}
\tableofcontents
\vspace{2cm}
\section*{}
\addcontentsline{toc}{section}{List of figures}
\listoffigures

\thispagestyle{empty}


\newpage



\section{What are the V0Finder and XiFinder ?}

Let's first define the 3 different sorts of secondary vertices :
\begin{itemize}
\item Kink vertices : when a charged particle decays into a charged plus a neutral,
\item V0 vertices : when a neutral particle decays into two charged particles,
\item Xi vertices : when a charged particle decays into a charged plus a neutral, and then the neutral daughter decays itself into two charged particles. One can't say that a Xi vertex is a Kink followed by a V0, because both charged tracks (mother and daughter) have to be seen in the {\sc tpc} in order to say that the vertex is a kink. This is not the case for Xi vertices, because the $c\tau$ of particles who do a Xi vertex if much shorter than the distance between the primary vertex and the {\sc tpc} ($50~cm$), even shorter than the distance to the first layer of the {\sc svt} ($6.7~cm$, versus $c\tau_{_\Xi} = 4.9~cm$ and $c\tau_{_\Omega} = 2.5~cm$).
%c\tau__\Xi marche mais fait erreurs a la compilation.
\end{itemize}

People working on strange particles in the strangeness group need a piece of code that is able to reconstruct the primary strange particles from the tracks. Those strange particles can be divided into two groups :
\begin{itemize}
\item {\bf V0's :} those particles ($\Lambda$, $K^0_s$) decay into two particles ($\Lambda \longrightarrow p \pi^-$, $K^0_s \longrightarrow \pi^+ \pi^-$). We need to be able to search and find them using only the daughter's tracks (that's all we have !).
\item {\bf Xi's :} those particles ($\Xi$, $\Omega$) decay into 1 charged particle -- called bachelor -- and a $\Lambda$ ($\Xi \longrightarrow \Lambda \pi^-$, $\Omega \longrightarrow \Lambda K^-$). The $\Lambda$, as said in the previous item, decays into two particles. So here, we need to find all combinations of 3 charged particles that are possibly the daughters of a unique strange particle.
\end{itemize}
The algorithms of those codes are described in the section \ref{sec3}.

From the beginning of {\sc star} and until year 2002, the codes used were what I will call afterwards {\em exiam} and {\em ev0am}. They are Fortran codes, located in {\tt pams/global/exi/\-exiam.F} and {\tt pams/global/\-ev0/\-ev0\_am2.F}, with other files that are necessary for the code to be run (basically subroutines and interfacing functions).

So here is the ``old" way to do things : the {\sc bfc} is run, and it calls the series of makers that it is supposed to call. Among those makers are {\tt StXiMaker} and {\tt StV0Maker} -- the strangeness makers, with {\tt StKinkMaker} -- and they are run after nearly all the other makers of the {\sc bfc}, since they need the tracks to be reconstructed and the primary vertex to be found. The V0Maker is run first, finds the V0's, and those feed the XiMaker, which tries to find Xi candidates for each V0. At a deeper level, inside the {\tt Make()} function of both the XiMaker and the V0Maker, are called the Fortran {\sc pam}s, i.e. respectively {\tt ev0am} and {\tt exiam}. {\sc pam} means either ``Plugable Analysis Module" or ``Physics Analysis Module". I don't know if somebody knows which of the two it is !

The interfacing between the {\sc bfc} (C++) and the {\sc pam}s (Fortran) won't be discussed here. If you want to know more, you can have a look at those files : {\tt pams/global/exi/\-exiam.idl}, {\tt pams/global/\-ev0/\-ev0\_am2.idl}, {\tt pams/idl/dst\_track.idl}, {\tt pams/idl/\-dst\_\-vertex.idl}, {\tt pams/idl/\-dst\_\-v0\_\-vertex.\-idl}, {\tt pams/idl/dst\_xi\_vertex.idl}. The data are passed -- from maker to maker, and also between a maker and the {\sc pam} it calls -- by tables. For example the tracks are stored in a table, and ev0am will read the table to have the tracks parameters. It will then store the V0's in another table. Then, exiam will read this table and the table of tracks, and write the Xi's found in a third table. Classes for interfacing have a general name which is ``St\_tableName\_Table.h", and they can be found in {\tt include/tables/} (as examples : {\tt St\_exi\_exipar\_Table.h}, {\tt St\_ev0\_aux\_Table.h}, {\tt St\_dst\_track\_Table.h}, {\tt St\_dst\_xi\_vertex\_Table.h}, etc... Further information about St\_\-dst\_\-track\_Table can be found at {\tt root.cern.ch/root/html/TTable.html} in the section ``Class description"). On the other hand, the corresponding structures are stored in {\tt pams/\-global/idl/}, in files like {\tt exi\_exipar.idl} (general name of the file : tableName.idl ; general name of the structure used afterwards : tableName\_st). You could have a look at e.g. {\tt StXiMaker::Init()} (the V0 and XiMaker's are in {\tt StRoot/St\_dst\_Maker/}) to have an example of how all this is used.

As explained in the section \ref{sec2}, the strangeness Fortran {\sc pam}s had to be replaced with C++ code. As exiam and ev0am refer to the corresponding {\sc pam}s, {\em XiFinder} and {\em V0Finder} are the names we gave to their C++ translations. They are makers, whose complete names are {\tt StXiFinderMaker} and {\tt StV0FinderMaker}. This is what we call the {\em strangeness StSecondaryVertexMaker package}.




\vspace{1cm}

\section{Historical purpose for StSecondaryVertexMaker package}
\label{sec2}

The StSecondaryVertexMaker package implements secondary vertex-finding
in C++. {\em Why ?}
There is and has been code for reconstucting secondary vertices
in the form of the {\tt ev0}, {\tt exi}, and {\tt tkf} {\sc pam}s. These {\sc pam}s were
written in Fortran and work with tables. They are called from C++
makers currently kept in the St\_dst\_Maker package library.
They work well, but suffer limitations :
\begin{itemize}
\item They cannot be re-run on {\sc dst}s after production,
\item They cannot operate on the tracking output of {\sc ittf}.
\end{itemize}
In order to overcome both limitations, the preffered solution is
to write C++ versions of these {\sc pam}s which can use StEvent
structures for both input and output (versus trying to convert
StEvent structures back into tables for input). This is the primary
purpose of the StSecondaryVertexMaker package.

Advantages of being able to run such a code on the {\sc dst}s are that analysis such as rotating can be done without running the whole {\sc bfc} on the daq files, as well as analysis that require modifications in the secondary vertex reconstruction code, like the value of the reconstruction cuts for example. The time profit is huge, since it takes more than 20 times more time to run the whole reconstruction chain than just the C++ secondary vertex reconstruction makers.




\vspace{1cm}

\section{Overall algorithms of the codes}
\label{sec3}

Apart from some parts described below, the V0Finder and XiFinder are essentially the ev0 and exi {\sc pam}s rewritten from Fortran to C++, from a ``tabelized" way of communicating to a standard object-oriented, mono-language code.

\subsection{KinkFinder}

To be written.

\subsection{V0Finder}

Cut parameters are initially requested from the database (time stamps determine what is the nature of the data, e.g. {\tt p-p}, {\tt Au-Au},
{\tt d-Au}). Then, tracks which satisfy a set of cuts are chosen as candidates for V0 daughters. The daughter candidates are then examined in pairs of negative and positive daughters to see if the
tracks approach each other and pass a series of cuts to determine if they are consistent with a V0 secondary decay.

Formerly, a second pass was required on the V0s. This was to facilitate their use in finding Xi decays. V0s from Xi decays are {\em secondary} V0s, and thus do not originate from the primary
vertex. This means looser cuts are necessary on these V0s than {\em primary} V0s. So, the first pass was made with the loose cuts, the Xi decays were found, and then the V0s were run through
tighter cuts to remove unused ones which were inconsistent with being primary V0s. This second pass prevented the output of significant numbers of unnecessary V0 candidates.

This second pass has been replaced by a different mechanism. Now, for each V0 which passes the looser secondary V0 cuts, a {\tt UseV0()} function is called. The idea is that a XiFinder can be
written which inherits from the V0Finder, and implements the {\tt UseV0()} function to find Xi candidates with a given V0. The {\tt UseV0()} function then returns true or false depending on
whether any Xi candidates are found using that V0. Upon returning to the V0Finder code, the V0 is discarded if it neither passes the cuts for a primary V0 nor gets used in the {\tt UseV0()} function.

This scheme has the advantage of not inserting a V0 into the StEvent vector of V0s unless it is a viable candidate. It also reduces considerably the memory overhead required during
V0-finding as not all of the secondary V0 candidates are found and stored at once (particularly poignant in high-multiplicity events where many thousands of secondary V0s are
considered). This only disadvantage is some overhead in making a function call in the middle of the V0-finding loop.

{\sc Fig.} \ref{V0Algo} shows that even if the code of the V0Finder is quite long, the alorithm is definitely simple.

%\begin{flushleft}
%
%\begin{array}{l}
%{\bf Loop} over positive tracks \\
%\[
%\left \lfloor
%\begin{array}{l}
%{\bf Loop} over negative tracks \\
%%Debut sous-tableau
%\[
%\left \lfloor
%\begin{tabular}{l}
%Find {\sc dca} between both helices \\
%Apply cuts \\
%{\bf If} {\em good candidate} : store \\
%\end{tabular}
%\right.
%\]
%%Fin sous-tableau
%\end{array}
%\right.
%\]
%\end{array}
%
%\caption{Overall algorithm of the V0Finder}
%\label{V0Algo}
%
%\end{flushleft}

%Ca chie : ca produit le bon resultat, mais ca fait des erreurs a la compilation.

%$
%\left \lfloor
%\begin{array}{l}
%xy \\
%\left \lfloor
%\begin{array}{ccc}
%   x + y & = & 0 \\
%   x - y & = & 0
%\end{array}
%\right.
%\end{array}
%\right.
%$

%La raison est que il ne comprend pas \[ et \] en mode math, et justement \[ et \] mettent implicitement ce qui est a l'interieur en mode math ! (Enfin +/-...). L'exemple ci-dessus marche, mais moi je voudrais que l'interieur soit en mode texte, pour mettre du texte dedans... Enfin plutot c'est pas accepte dans l'environnement tabular, mais je n'ai rien d'autre pour faire des retours a la ligne ("\\" marche pas).

% OK : d'apres doc, \[ et \] sont raccourcis pour environnement displaymath, dont un autre raccourci est... $$...$$ !
% D'ailleurs, je suis etonne qu'il accepte tabular dans un mode Math !

%\begin{flushleft}
\begin{center}
%\mathversion{bold} 
%Marche pas (ca fait rien). Package amsmath.
$
%Avec $$...$$, il centre, meme dans le flushleft.
\begin{array}{c}
\begin{tabular}{|c|}
\hline
Container of tracks \\
\hline
\end{tabular} \\
%\boldsymbol{\downarrow} \\ %Ca marche (package amsmath)
%\boldsymbol{\Big \downarrow} \\ %Ca marche pas, ca fait une \Big \downarrow normale.
%\pmb{\downarrow} \\ %Ca marche (package amsmath) mais c'est putain de gras !! Et c'est moche.
\pmb{\Big \downarrow} \\ %Ca marche (package amsmath) mais c'est putain de gras !! (A peine moins que le precedent, plus que \boldsymbol{\downarrow}). Et c'est moche.
%\Big \downarrow \\
\begin{array}{|ll|}
\hline
\hspace{4pt}~ & % Pour eviter que soit colle contre le bord gauche.
% Mais il faut que le hspace soit suivi d'un caractere a sa droite (si a sa gauche, ca marche pas, car a sa droite est le bord de la colonne, donc il s'en fout). Par exemple "~" ou "\ " (les 2 marchent).
\hspace{-10pt} \begin{tabular}{l} {\bf Loop} over positive tracks \\ \end{tabular} \\
% Le hspace est necessaire, car le fait de faire un tableau decale le texte (le tableau est invisible).
\hspace{4pt}~ & % Pour eviter que soit colle contre le bord gauche.
\left \lfloor
\begin{array}{l}
%{\textstyle {\bf Loop} over negative tracks} \\
%Ca chie : aucune action.
%\textstyle{{\bf Loop} over negative tracks} \\
%Pas mieux. Donc methode bourrin...
\hspace{-10pt} \begin{tabular}{l} {\bf Loop} over negative tracks \\ \end{tabular} \\
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Find {\sc dca} between both helices \\
Apply cuts \\
{\bf If} {\em good candidate} : store \\
\end{tabular}
\right. \\
\vspace{-11pt}
%Le \\ sert a faire un ligne apres la fermuture du \lfloor. Mais il n'y a rien sur cette ligne, donc le \lfloor exterieur n'enveloppe toujours pas le \lfloor interieur jusqu'au bout. Si on ajout un \vspace, il ajoute une ligne entiere en plus du vspace. Il faut donc lui mettre un vspace negatif.
\end{array}
\right. \\
\hline
\end{array} \\
%\Big \downarrow \\
\pmb{\Big \downarrow} \\
\begin{tabular}{|c|}
\hline
Container of V0 vertices \\
\hline
\end{tabular} \\
\end{array}
$
\mycaption{Overall algorithm of the V0Finder}
\label{V0Algo}

%\end{flushleft}
\end{center}



\subsection{XiFinder}

The {\tt StXiFinderMaker} inherits from {\tt StV0FinderMaker} as indicated above. Because it is actually a V0Finder itself via this inheritance, one need not instantiate a {\tt StV0FinderMaker} if one
instantiates a {\tt StXiFinderMaker}.

Similar to the {\tt StV0FinderMaker}, appropriate cut parameters are initially requested from the database. The same tracks that are considered for the V0s are also used as daughter candidates
for the Xis. The {\tt Make()} member function then simply calls the inherited {\tt Make()} member function from the {\tt StV0FinderMaker}. Control comes back to the {\tt StXiFinderMaker} at the call to
{\tt UseV0()}, which is implemented here as a loop over Xi daughter candidates to be paired with the V0 daughter candidate. If the daughters approach each other and pass a series of cuts, the
candidate is accepted and stored in StEvent. Control is then passed back to the V0Finder, with a return value indicating whether the V0 was in fact used.

As for the V0Finder, {\sc Fig.} \ref{XiAlgo} below shows that the XiFinder alorithm is very simple, although the code is long. More detailed algorithms can be found in section \ref{sec4}.

%\begin{flushleft}
\begin{center}

%\begin{tabular}{l}
%{\bf Loop} over V0 vertices \\
%\[
%\left \lfloor
%\begin{tabular}{l}
%Apply cuts on the V0 and V0 daughters \\
%{\bf Loop} over global tracks \\
%%Debut sous-tableau
%\[
%\left \lfloor
%\begin{tabular}{l}
%{\bf If} {\em track has wrong charge} : next \\
%{\bf If} {\em track already used in the V0} : next \\
%Find {\sc dca} between V0's straight line and track's helix \\
%Apply cuts \\
%{\bf If} {\em good candidate} : store \\
%\end{tabular}
%\right.
%\]
%%Fin sous-tableau
%\end{tabular}
%\right.
%\]
%\end{tabular}

$
\begin{array}{c}
\begin{tabular}{r|>{\centering}p{4.2cm}|>{\centering}p{4.2cm}|l}
\cline{2-3}
& Container of V0 vertices & Container of tracks & \\
\cline{2-3}
\end{tabular} \\
\pmb{\Big \downarrow} \\
\begin{array}{|ll|}
\hline
\hspace{4pt}~ &
\hspace{-10pt} \begin{tabular}{l} {\bf Loop} over V0 vertices \\ \end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\begin{array}{l}
\hspace{-10pt} \begin{tabular}{l} Apply cuts on the V0 and V0 daughters \\ {\bf Loop} over global tracks \\ \end{tabular} \\
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
{\bf If} {\em track has wrong charge} : next \\
{\bf If} {\em track already used in the V0} : next \\
Find {\sc dca} between V0's straight line and track's helix \\
Apply cuts \\
{\bf If} {\em good candidate} : store \\
\end{tabular}
\right. \\
\vspace{-12pt}
\end{array}
\right. \\
\hline
\end{array} \\
\pmb{\Big \downarrow} \\
\begin{tabular}{|c|}
\hline
Container of Xi vertices \\
\hline
\end{tabular} \\
\end{array}
$


\mycaption{Overall algorithm of the XiFinder}
\label{XiAlgo}

%\end{flushleft}
\end{center}


%\begin{tabular}
%{|>{\raggedleft}p{1in}
% |>{\centering}p{1in}
%	|>{(\raggedright}p{1in}<{)}
%	|l|}
%\hline
%blabla & blabla & blabla & blabla \\
%\hline
%\end{tabular}
% Ca, ca marche. Mais des qu'on vire la 4e colonne, ca marche plus... Solution crade :
%\begin{tabular}
%{|>{\raggedleft}p{1in}
% |>{\centering}p{1in}
%	|>{(\raggedright}p{1in}<{)}
%	|l}
%\cline{1-3}
%blabla & blabla & blabla & \\
%\cline{1-3}
%\end{tabular}
%... que je vais implementer dans le tableau ci-dessus illico.









\vspace{1cm}

\section{Structure of the Fortran and C++ codes}
\label{sec4}

The first thing to mention is a change in the interaction between the V0Finder and the XiFinder. The XiFinder actually uses the V0's that have first been found by the V0Finder. The table below shows how this is done in the Fortran code :

\begin{center}
\begin{tabular}{|l|l|}
\hline
Call {\tt StV0Maker::Make()} & Finds V0's and store them in a table \\
Call {\tt StXiMaker::Make()} & Loop over the V0's in the table to find Xi candidates \\
Call {\tt StV0Maker::Trim()} & Loop over the V0's in the table to throw away the \\
&  non-primary V0's that are not used in a Xi candidate \\
\hline
\end{tabular}
\end{center}

This waste of memory (storing V0's that will be deleted afterwards) and of time (scanning twice the table of V0's) is solved in the C++ code, by the fact that the class {\tt StXiFinderMaker} actually inherits from {\tt StV0FinderMaker}. The member-functions of each of them and their role are listed in {\sc Fig}. \ref{fonctions-membres}.

Note that {\tt StXiFinderMaker::Init()} is the equivalent of {\tt StV0FinderMaker::GetPars()}. The effect of the function {\tt StV0FinderMaker::DontZapV0s} is that the V0's that are already in StEvent are kept, the V0's found by the V0Finder will be added. The function {\tt StV0FinderMaker::UseExistingV0s} also keeps the V0's that are already in StEvent, but also prevents the V0Finder to be run, and forces the XiFinder to use the V0's previously found. The function {\tt StV0FinderMaker::UseITTFTracks} has been implemented for {\sc ittf} test purposes, since it allows the user to choose between using the {\sc ittf} tracks or using the tracks found by the standard reconstruction.

When the V0Finder is run alone, the method {\tt StV0FinderMaker::UseV0()} is called for each V0 found, and returns {\tt false}, since we don't want to find Xi's.

When both the XiFinder and V0Finder are run, the XiFinder first calls {\tt StV0FinderMaker::Make()}. This function finds V0's and, for each of them, calls the {\tt UseV0()} method. The latter runs the XiFinder algorithm, that will eventually tell {\tt StV0FinderMaker::Make()} if the current V0 has been used in Xi candidates or not. This way to do, compared with the Fortran one, saves time and memory.

\begin{center}
\begin{tabular}{|r|l|l|}
\hline
Function & Role in the V0Finder & Role in the XiFinder \\
\hline
\hline
{\tt Init} & Inits & Gets {\tt exipar} from the database \\
\hline
{\tt Make} & V0Finder ``central" algorithm & Calls the V0Finder \\
\hline
{\tt Clear} & Clears & Not redefined \\
\hline
{\tt GetPars} & Gets {\tt ev0par2} from the database & Not redefined (not used) \\
\hline
{\tt Prepare} & Finds event-wise parameters, fills tables & Not redefined \\
\hline
{\tt UseV0} & Returns {\tt false} & XiFinder ``central" algorithm \\
\hline
{\tt UseExistingV0s} & Sets a boolean flag & Not redefined \\
\hline
{\tt DontZapV0s} & Sets a boolean flag & Not redefined \\
\hline
{\tt UseITTFTracks} & Sets a boolean flag & Not redefined \\
\hline
{\tt UsingITTFTracks} & Returns a boolean flag & Not redefined \\
\hline
{\tt Trim} & Remove the V0's that don't pass cuts & Not redefined (not used) \\
\hline
\end{tabular}
\mycaption{Member-functions of {\tt StV0FinderMaker} and {\tt StXiFinderMaker}}
\label{fonctions-membres}

\end{center}

The table below shows how this is run in the C++ XiFinder (provided that it's the XiFinder that is called and not just the V0Finder) :

\begin{center}
\begin{tabular}{|l|l|}
\hline
Call {\tt StXiFinderMaker::Make()} & (Calls everything below) \\
~~~~ Call {\tt StXiFinderMaker::Prepare()} & Finds event-wise parameters and fills the tables \\
~~~~ Call {\tt StV0FinderMaker::Make()} & Finds V0's in this event \\
~~~~~~~~~ Call {\tt StXiFinder::UseV0()} & Finds Xi's for a given V0 and store them in StEvent \\
~~~~ (back in {\tt V0FinderMaker::Make}) & If V0 is used in Xi's / may be primary : store in StEvent \\
\hline
\end{tabular}
\end{center}



\subsection{KinkFinder}

To be written.


\subsection{V0Finder}

{\sc Fig}. \ref{V0AlgoMieux} shows the detailed structure of the V0Finder, with all the cuts that are applied. Of course, more accurate information can be found... by looking at the code ;-)~.

Before the loops, tables called {\tt ptrks}, {\tt ntrks}, etc..., are filled in the function {\tt StV0FinderMaker::Prepare()}, and the values used afterwards are those that are stored in these tables, in order to improve the speed of the code. The XiFinder doesn't use them yet... but will.

The cuts' value are got in the function {\tt StV0FinderMaker::GetPars()}, and stored in the member objects {\tt pars} and {\tt pars2}. Here are the components :
\begin{itemize}
\item {\tt n\_point} : number of hits,
\item {\tt dcapnmin} : distance of closest approach between the daughter tracks and the primary vertex,
\item {\tt dca} : distance of closest approach between the V0 daughters,
\item {\tt dlen} : decay length of the V0,
\item {\tt dcav0} : distance of closest approach between the V0 trajectory and the primary vertex,
\item {\tt alpha\_max} : $\alpha$ Armanteros,
\item {\tt ptarm\_max} : $p_\perp$ Armanteros.
\end{itemize}

\begin{center}
$
\begin{array}{|ll|}
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
Get parameters from database \\
Get event \\
Get position of the primary vertex \\
{\bf Loop} over all tracks \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Select normal vs {\sc ittf} \\
{\bf If} {\it bad flag} : next \\
{\bf If} {\it bad detector {\sc id}} : next \\
Store track and parameters in tables \\
%\hspace{1cm} (separately pos. and neg.) \\
\hfill (separately pos. and neg.) \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf Loop} over positive tracks \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\begin{array}{l}
\hspace{-10pt} \begin{tabular}{l} {\bf Loop} over negative tracks \\ \end{tabular} \\
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Determine V0's detector {\sc id} \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on number of hits \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on dcaTrackToPvx \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on $p_\perp$ \\
Find number of intersection points between both helices \\
Find 2D dca between both helices at both intersection points\\
Keep the smallest dca \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} if one track points away from Pvx \\
Calulate approximated 3D dca between both helices \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on dcaV0Daughters \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} ..............\\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on decay length from Pvx \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} if V0 points away from Pvx \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on dcaV0ToPvx \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on $\alpha_{Arm}$ \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on $p_{\perp_{Arm}}$ \\
Fill an {\tt StV0Vertex} \\
Call {\tt UseV0} to find if V0 is used for Xis \\
{\bf If} {\it primary or used in Xi} : store \\
\end{tabular}
\right. \\
\vspace{-11pt}
\end{array}
\right. \\
%\hspace{4pt}~ & \vspace{-10pt} \\
%Ca fait bien remonter la hline, mais pas les 2 bords verticaux du tableau ! Du coup, la fin de l'"accolade" exterieure touche un peu la ligne du bas du tableau (hline), mais tant pis.
\hline
\end{array}
$
\mycaption{Algorithm of the V0Finder}
\label{V0AlgoMieux}

\end{center}




\subsection{XiFinder}

\subsubsection{Differences between Fortran and C++}

The differences between the Fortran code and the C++ code are shown in {\sc Fig}. \ref{XiFC}, on the half-detailed algorithm. The red lines show what has disappeared, either because of the new structure of the code, or because of the fact that we are using StEvent. The green lines show the parts that have been reshaped, for the same reasons as several parts have been removed.

Apart from these modifications, the code is a simple translation from Fortran to C++. This may change once we are convinced that the C++ code has no bug : we may then want to have the code more readable, or better organised, or we may even want to replace some calculation algorithms.

So far, the code is all in one block, for speed purposes, and the beginning and end of each former Fortran subroutine is indicated by commented lines. Once again, when we are sure that we don't need to compare the C++ and Fortran codes anymore, we'll probably remove all this.

Avoiding calls to subfunctions resulted in a duplication of a certain part of the code. Figure \ref{blocs} show how the C++ code structure fits to the Fortran one, but let's detail the changes (green lines in {\sc Fig}. \ref{XiFC}) one by one.




\begin{center}

$
\begin{array}{cc}
\begin{array}{|ll|}                 %Debut array 0
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
Do things... \\
{\bf Loop} over V0 vertices \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor                       %Accolade 1
\begin{array}{l}                    %Debut array 1
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 1
\textcolor{red}{Find vertex key} \\
Hits in which detectors \\
\textcolor{green}{Lambda mass checks, cuts} \\
{\bf Loop} over global tracks \\
\end{tabular} \\                    %Fin tableau 1
\left \lfloor                       %Accolade 2
\begin{array}{l}                    %Debut array 2
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 2
Select correct charge \\
Don't use V0 tracks \\
Hits in which detectors \\
\textcolor{red}{Parameters conversion} \\
\textcolor{red}{Subroutine {\tt circle\_param}} \\
Calculate dca V0/bachelor in 2D \\
\textcolor{green}{Subroutine {\tt casc\_geom}} \\
\textcolor{green}{{\bf Loop} over the 2 intersect. points} \\
\end{tabular} \\                       %Fin tableau 2
\left \lfloor                       %Accolade 3
\hspace{-4pt}
\begin{tabular}{l}                  %Debut tableau 3
Subroutine {\tt update\_track\_param} \\
Approxim. of 3D-dca by lineari- \\
\hfill zation of the helix \\
\textcolor{red}{Subroutine {\tt track\_mom}} \\
Check validity of linear approx. \\
Subroutine {\tt ev0\_project\_track} \\
{\bf If} {\em not good} : try again (up to 3 \\
\hfill tries) \\
\textcolor{green}{{\bf If} {\em cuts OK} : fill table} \\
\end{tabular}                       %Fin tableau 3
\right. \\                          %Accolade 3
\vspace{-12pt}
\end{array}                         %Fin array 2
\right. \\                          %Accolade 2
\vspace{-12pt}
\end{array}                         %Fin array 1
\right. \\                          %Accolade 1
\hline
\end{array}                         %Fin array 0
&
\begin{array}{|ll|}                 %Debut array 0
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
Do things... \\
{\bf Loop} over V0 vertices \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor                       %Accolade 1
\begin{array}{l}                    %Debut array 1
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 1
~ \\
Hits in which detectors \\
\textcolor{green}{Lambda mass checks, cuts} \\
{\bf Loop} over global tracks \\
\end{tabular} \\                    %Fin tableau 1
\left \lfloor                       %Accolade 2
\begin{array}{l}                    %Debut array 2
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 2
Select correct charge \\
Don't use V0 tracks \\
Hits in which detectors \\
~ \\
~ \\
Calculate dca V0/bachelor in 2D \\
\textcolor{green}{Subroutine {\tt casc\_geom}} \\
\textcolor{green}{{\bf Loop} over the 2 intersect. points} \\
\end{tabular} \\                       %Fin tableau 2
\left \lfloor                       %Accolade 3
\hspace{-4pt}
\begin{tabular}{l}                  %Debut tableau 3
Subroutine {\tt update\_track\_param} \\
Approxim. of 3D-dca by lineari- \\
\hfill zation of the helix \\
~ \\
Check validity of linear approx. \\
Subroutine {\tt ev0\_project\_track} \\
{\bf If} {\em not good} : try again (up to 3 \\
\hfill tries) \\
\textcolor{green}{{\bf If} {\em cuts OK} : fill StEvent} \\
\end{tabular}                       %Fin tableau 3
\right. \\                          %Accolade 3
\vspace{-12pt}
\end{array}                         %Fin array 2
\right. \\                          %Accolade 2
\vspace{-12pt}
\end{array}                         %Fin array 1
\right. \\                          %Accolade 1
\hline
\end{array}                         %Fin array 0
\end{array}
$

\mycaption{Algorithm of the XiFinder}
\label{XiFC}

\end{center}


The reshaping of the Lambda mass calculation consisted simply in calculating the invariant mass using other parameters : taking the example of the $\Lambda$ invariant mass, we have :
$$
\begin{array}{r@{~=~}l}
m^2_\Lambda & E^2_\Lambda - \overrightarrow{p}^2_\Lambda \\
& (E_++E_-)^2 - (\overrightarrow{p}_++\overrightarrow{p}_-)^2 \\
& E^2_+ + E^2_- + 2E_+E_- - \overrightarrow{p}^2_+ - \overrightarrow{p}^2_- - 2\overrightarrow{p}_+\overrightarrow{p}_- \\
\end{array}
$$
In Fortran, the $E$ and $\overrightarrow{p}$ terms are grouped together, and the invariant mass is calculated with this formula :
$$m^2_\Lambda = m^2_p + m^2_\pi + 2E_+E_- - 2\overrightarrow{p}_+\overrightarrow{p}_-$$
In C++, energies and momenta are kept separated, and the formula used is, as already written above :
$$
\begin{array}{r@{~=~}l}
m^2_\Lambda & (E_++E_-)^2 - (\overrightarrow{p}_++\overrightarrow{p}_-)^2 \\
& \left(\sqrt{\overrightarrow{p}^2_++m^2_p} + \sqrt{\overrightarrow{p}^2_-+m^2_\pi}\right)^2 - \overrightarrow{p}^2_\Lambda \\
\end{array}
$$


To modify the structure of {\em casc\_geom} and of the loop coloured in green in {\sc Fig}. \ref{XiFC}, I've written the Fortran code as a set of for-loops, if-loops, goto's and blocks of instructions. The figures below show those reashapings : {\sc Fig}. \ref{cascgeom} shows the reshaping of {\em casc\_geom}, and {\sc Fig}. \ref{blocs} shows the reshaping of the inside of the loop over the intersection points (between the bachelor's helix and the V0's straight line). In {\sc Fig}. \ref{blocs}, what is called {\em Block 5} is actually a huge part of the program, and it hasn't been reshaped.

\begin{center}
$
\begin{array}{ccc}
\begin{array}{|ll|}                   %Debut array 0
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf if} ($p_x \ne 0$) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 1 \\
{\bf if} ($c < 0$) {\bf goto} 137 \\
Block 2 \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf else} ~~{\tt //}($p_x == 0$) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 3 \\
{\bf if} ($c < 0$) {\bf goto} 137 \\
Block 4 \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf exit} ~~{\tt //}(from the subroutine) \\
\end{tabular} \\

\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf Lbl} 137 \\
{\bf if} ($p_x \ne 0$) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 5 \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf else} ~~{\tt //}($p_x == 0$) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 6 \\
\end{tabular}
\right. \\
\hline
\end{array}                           % Fin array 0

&
\Longrightarrow\hspace{-18pt}\Longrightarrow
&

\begin{array}{|ll|}                   %Debut array 0
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf if} ($p_x \ne 0$) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 1 \\
{\bf if} ($c < 0$) Block 5 \\
~~~ {\bf else} Block 2 \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf else} ~~{\tt //}($p_x == 0$) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 3 \\
{\bf if} ($c < 0$) Block 6 \\
~~~ {\bf else} Block 4 \\
\end{tabular}
\right. \\
\hline
\end{array}                           % Fin array 0
\end{array}
$
\mycaption{Reshaping of {\tt casc\_geom} : Fortran to C++}
\label{cascgeom}

\end{center}

\begin{center}

$
\begin{array}{ccc}
\begin{array}{|ll|}                 %Debut array 0
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\tt tries=1} \\
Block 1 \\
{\bf Lbl} 60 \\
Block 2 \\
{\bf if} ({\tt cond1} \&\& {\tt tries$\le$3}) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor                       %Accolade 1
\begin{array}{l}                    %Debut array 1
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 1
Block 3 \\
{\bf if} ({\tt cond2}) ~~{\tt //}(Depends on Block 2)\\
\end{tabular} \\                    %Fin tableau 1
\left \lfloor                       %Accolade 2
\begin{array}{l}                    %Debut array 2
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 2
{\tt tries++} \\
Block 4 \\
{\bf Goto} 60 \\
\end{tabular} \\                       %Fin tableau 2
\vspace{-12pt}
\end{array}                         %Fin array 2
\right. \\                          %Accolade 2
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 1
Block 5 \\
\end{tabular} \\                    %Fin tableau 1
\vspace{-12pt}
\end{array}                         %Fin array 1
\right. \\                          %Accolade 1
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf if} ({\tt cond3}) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor                       %Accolade 1
\begin{array}{l}                    %Debut array 1
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 1
{\bf Goto} 30 ~~{\tt //}(Just after the for-loop)\\
\end{tabular} \\                    %Fin tableau 1
\vspace{-16pt}
\end{array}                         %Fin array 1
\right. \\                          %Accolade 1
\hline
\end{array}                         %Fin array 0

&
\Longrightarrow\hspace{-18pt}\Longrightarrow
&

\begin{array}{|ll|}                   %Debut array 0
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\tt tries=1} \\
Block 1 \\
Block 2 \\
{\bf while} ({\tt cond1} \&\& {\tt tries$\le$3} \&\& {\tt cond2}) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
{\tt tries++} \\
Block 3 \\
Block 4 \\
Block 2 \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf if} ({\tt cond1} \&\& {\tt tries$\le$3}) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 3 \\
Block 5 \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf if} ({\tt cond3}) {\bf break} \\
\end{tabular} \\
\hline
\end{array}                           % Fin array 0
\end{array}
$

\mycaption{Reshaping of the loop over the intersection points : Fortran to C++}
\label{blocs}

\end{center}


\subsubsection{Calculation of the intersection points}

Now, here is how are calculated the coordinates of the intersection points {\em in the bending plane (xOy)} between the V0's straight line and the bachelor's helix (actually, of their projection in the bending plane). This is done in the code in the former subroutine {\tt casc\_geom}.

Let's call $\Delta$ the projection of the V0's trajectory, and $\mathcal C$ the circle that is the projection of the bachelor's trajectory. Their equations are :
$$\Delta : y=ax+b \qquad\qquad\qquad {\mathcal C} : (x-x_c)^2+(y-y_c)^2 = R^2$$

Calling $(x_0,y_0)$ a point on the V0's trajectory, and $\overrightarrow{p} = (p_x,p_y,p_z)$ its momentum, we obtain :
$$a = \frac{p_y}{p_x} \qquad\qquad\qquad b = y_0-\frac{p_y}{p_x}x_0$$
Thus :
$$\Delta : y = \frac{p_y}{p_x}(x-x_0)+y_0$$
If we change the variables, with $X=x-x_c$ and $Y=y-y_c$, we have :
$$\Delta : Y = \frac{p_y}{p_x}(X+x_c-x_0)+y_0-y_c \qquad\qquad\qquad {\mathcal C} : X^2+Y^2 = R^2$$

Now, we can search the intersection points. If we call $\delta_x = x_c-x_0$ and $\delta_y = y_c-y_0$, we have to solve this system of equations :
$$
\left\{
\begin{array}{r@{~=~}l}
Y^2 & R^2-X^2 \\
Y^2 & \left(\frac{p_y}{p_x}(X+\delta_x)-\delta_y\right)^2 \\
\end{array}
\right.
$$
which, if we define $\alpha = p_y/p_x$ and $\beta = \alpha\delta_x-\delta_y$, and modify the equations, becomes :
$$
\left\{
\begin{array}{l}
Y = \alpha(X+\delta_x)-\delta_y \\
X^2(\alpha^2+1) + 2\alpha\beta X + \beta^2 - R^2 = 0 \\
\end{array}
\right.
$$
If the condition $R^2(\alpha^2+1) \ge \beta^2$ is true, then we have 2 solutions, that are :
$$
\left\{
\begin{array}{l}
Y = \alpha(X+\delta_x)-\delta_y \\
X = \frac{\alpha\beta\pm\sqrt{R^2(\alpha^2+1)-\beta^2}}{\alpha^2+1} \\
\end{array}
\right.
$$

The 2-D coordinates of these 2 points are stored in the code in variables called {\tt xOut} and {\tt yOut}.








\subsubsection{Calculation of the dca between the V0 and the bachelor}
\label{paragrDca}

The algorithm that calculates the dca between the V0 (a line) and the bachelor (a helix) is rather intuitive (see also {\sc Fig.} \ref{XiAlgoMieux}). This dca can't be calculated analytically, so the trick is to linearise the helix locally. This means that we will assume, for the dca calculation, that the helix is equal to its tangent at the intersection point between the helix and the V0 line.
\label{linearisation}

Then, the position of the point of the tangent where the distance to the V0 line is the smallest is calculated. To check that the linearisation is not a too strong approximation, the disctance between that point and the actual helix is calculated, and is required to be smaller than a certain fraction of the helix' radius. If this is true but if the distance is yet bigger than another fraction of the helix' radius (obviously smaller than the previous one), then the helix is linearised at the calculated point (instead of the intersection point in 2-D), and the calculation is re-done.

This is done 3 times, or less if the distance between the calculated point and the actual helix matches the second criterium after less than 3 loops. So all the candidates that match the first criterium are kept, and those not matching the second criterium are simply improved by trying 3 times to linearise the helix at a point that is closer to the actual point where the distance to the V0 line is the smallest.

The first part of the algorithm is illustrated by the figure \ref{calcFig1}, which shows the projection in the plane $(xOy)$ of the cascade geometry : that gives the circle $\mathcal C$ (projection of the helix) and the line $\Delta$ (projection of the 3-D line). $M$ is one of the 2 intersection points (always in 2-D ; in 3-D, the helix and the line almost never intersect), $C$ is the center of the circle, $R$ its radius, and $A$ is the projection of what is called the origin of the helix (it's most often the first hit point, or more exactly the point of the helix that is closest to the first hit, since the helix is a fit). $\Psi$ is the angle between the $x$ axis and the tangent to the circle in $A$. For lack of imagination, I'll keep the same names for the non-projected objects later ;-) ~~ (i.e. $\mathcal C$ for the helix, $\Delta$ for the V0 line and $A$ for the origin (not its projection) of the helix).

\begin{center}

\epsfig{file=calcFig1.eps,width=11cm}

\mycaption{Projection of the cascade geometry in the 2-D plane (xOy)}
\label{calcFig1}
\end{center}

%{\small{\normalsize 
%The first part of the code that is run is the former subroutine {\tt update\_track\_param}. Its role is simply to move the orgin of the helix from its former position $A$ to its new position $M$ (actually, the point of the helix that overlaps with $M$ when projected to the $(xOy)$ plane).
%}\par}

%{\advance\baselineskip -5pt 
%The first part of the code that is run is the former subroutine {\tt update\_track\_param}. Its role is simply to move the orgin of the helix from its former position $A$ to its new position $M$ (actually, the point of the helix that overlaps with $M$ when projected to the $(xOy)$ plane).
%\par}

%{\setlength{\baselineskip}{0.2\baselineskip}
%The first part of the code that is run is the former subroutine {\tt update\_track\_param}. Its role is simply to move the orgin of the helix from its former position $A$ to its new position $M$ (actually, the point of the helix that overlaps with $M$ when projected to the $(xOy)$ plane).
%\par}

% Les 3 marchent, mais impossible de descendre en-dessous d'une certaine valeur !
% Au fait : ce que ca fait est que ca reduit (ou augmente) l'interligne.

The first part of the code that is run is the former subroutine {\tt update\_track\_param}. Its role is simply to move the orgin of the helix from its former position $A$ to its new position $M$ (actually, the point of the helix that overlaps with $M$ when projected to the $(xOy)$ plane).

%{\small{\normalsize 
% Pareil : ca descend pas en-dessous d'une certaine valeur, ici bien trop grande.
% Donc je me definis mon propre style de liste :-)
Here is a list of the various variables in this area of the code :
\begin{maliste}
\item {\tt xi} : $x$ coordinate of the origin
\item {\tt yi} : $y$ coordinate of the origin
\item {\tt axb} : $\overrightarrow{CA} \cdot \overrightarrow{w}$, where $\overrightarrow{w}$ is the vector such as $\|\overrightarrow{w}\| = \|\overrightarrow{CM}\|$ and $(\widehat{\overrightarrow{CM},\overrightarrow{w}}) = -\frac{\pi}{2}$
\item {\tt arg} : $\sin(\overrightarrow{CA},\overrightarrow{CM})$
\item {\tt ds} : curvilinear length on the {\em circle} between $A$ and $M$
\item {\tt dz} : $z_M - z_A$
\end{maliste}
And what follows is how to do the link between the code and the mathematical formulas :\\
In the code : {\tt axb = (xi-xc)(yOut-yc) - (yi-yc)(xOut-xc)}
$$
\overrightarrow{CA} =
\left|\begin{array}{l}
x_{_A} - x_{_C} \\
y_{_A} - y_{_C} \\
\end{array}\right.
\qquad\qquad
\overrightarrow{CM} =
\left|\begin{array}{l}
x_{_M} - x_{_C} \\
y_{_M} - y_{_C} \\
\end{array}\right.
\qquad\qquad
\overrightarrow{w} =
\left|\begin{array}{l}
y_{_M} - y_{_C} \\
-(x_{_M} - x_{_C}) \\
\end{array}\right.
$$
So $\overrightarrow{CA} \cdot \overrightarrow{w} = (x_{_A}-x_{_C})(y_{_M}-y_{_C}) - (y_{_A}-y_{_C})(x_{_M}-x_{_C}) = \text{\tt axb}$.\\
%$\overrightarrow{w} \perp \overrightarrow{CM}$, so $\overrightarrow{w}$ drives the tangent to the circle in $M$.
Now, let's try to find what is $\text{\tt axb} = \overrightarrow{CA} \cdot \overrightarrow{w}$ :\\
we know that $\|\overrightarrow{w}\| = \|\overrightarrow{CM}\|$, so :
$$
\begin{array}{r@{\;=\;}l}
\overrightarrow{CA} \cdot \overrightarrow{w} & \|\overrightarrow{CA}\| \cdot \|\overrightarrow{w}\| \cos(\overrightarrow{CA},\overrightarrow{w}) \\
 & \|\overrightarrow{CA}\| \cdot \|\overrightarrow{CM}\| \cos((\overrightarrow{CA},\overrightarrow{CM}) + (\overrightarrow{CM},\overrightarrow{w})) \\
	& R^2 \cos((\overrightarrow{CA},\overrightarrow{CM}) - \frac{\pi}{2}) \\
	& R^2 \sin(\overrightarrow{CA},\overrightarrow{CM}) \\
\end{array}
$$
Therefore, since $\text{\tt rsq} = R^2$, we obtain $\text{\tt arg} = \text{\tt axb/rsq} = \sin(\overrightarrow{CA},\overrightarrow{CM})$.\\
{\tt ds} is then defined as the angle ($\arcsin(\text{\tt arg})$) multiplied by $R$, i.e. it is the curvilinear length on the circle from $A$ to $M$.\\
And then, from the definition of the dip angle\footnote{For a detailed note about the helices' parameters, see the appendix A of the Star Class Library documentation.}, we obtain that {\tt dz = ds.tan(dipAngle)} is $z_M - z_A$ (considering this time $A$ and $M$ as the points on the helix instead of on the circle).
%}\par}

At the end of the former subroutine {\tt update\_track\_param}, a helix called {\tt bachGeom2} is booked with the same parameters than the original bachelor helix taken from the track container, {\tt bachGeom}, except for the origin that has been moved from $A$ to $M$, and the angle $\Psi$ that obviously changes when the origin moves (see {\sc Fig.} \ref{calcFig1}).

The next piece of code is the former subroutine {\tt track\_mom}, which just books the momentum of the bachelor taken in $M$ in the variable {\tt xOrig} (which contained the 3-D position of $M$ a couple of code-lines before : since both usages don't overlap, the same StThreeVector can be used for both of them).

The next part of the code is the most difficult one to understand. It wasn't a subroutine in the Fortran code : that was part of the {\tt exiam} function.
Here is a list of the various variables in this area of the code :
\begin{maliste}
\item {\tt pBach} : normalised momentum of the bachelor in $M$ (so it's rather the (normalised) direction of the tangent to the helix in $M$)
\item {\tt dv0dotdb} : $\cos (\overrightarrow{\text{\tt dpV0}},\overrightarrow{\text{\tt pBach}})$
\item {\tt diffc} : $\overrightarrow{MV}$, calling $V$ the point where the V0 decays
\item {\tt denom} : $\cos^2 (\overrightarrow{\text{\tt dpV0}},\overrightarrow{\text{\tt pBach}}) - 1$
\item {\tt s2} : ehm... well... see the explanations below !
\item {\tt valid} : relative error due to the linearisation
\end{maliste}
So let's call $V$ the position of the V0 vertex, i.e. the point where the V0 decays. As described p. \pageref{linearisation}, we now linearise the helix, i.e. we now assume that the helix can be merged with its tangent in $M$. So an approximation of the point where the distance between the helix and the V0 line is the smallest is the point where the distance between the tangent to the helix and the V0 line is the smallest.

Let $\mathcal D$ be the tangent to the helix in $M$, $\Delta$ being the V0 line, and let $H_1$ (resp. $H_2$) be the point on $\Delta$ (resp. on $\mathcal D$) where the distance to $\mathcal D$ (resp. to $\Delta$) is the smallest.

Calling $\overrightarrow{u}$ the vector that drives $\Delta$ (i.e. $\overrightarrow{u} = \overrightarrow{\text{\tt dpV0}}$) and $\overrightarrow{v}$ the vector that drives $\mathcal D$ (i.e. $\overrightarrow{v} = \overrightarrow{\text{\tt pBach}}$), we can write $H_1$ and $H_2$ as :
$$
H_1 = V + k_1 \overrightarrow{u}
\qquad\qquad
H_2 = M + k_2 \overrightarrow{v}
$$
With the definition of $H_1$ and $H_2$ above, we can write that we search :
\begin{equation}\label{k1k2}(H_1 \in \Delta , H_2 \in {\mathcal D}) \quad / \quad \overrightarrow{H_1 H_2} \perp \Delta \quad \text{and} \quad \overrightarrow{H_1 H_2} \perp {\mathcal D}
\end{equation}
\begin{equation}\label{Systeme}
\Leftrightarrow \quad (H_1 \in \Delta , H_2 \in {\mathcal D}) \quad / \quad \overrightarrow{H_1 H_2} \cdot \overrightarrow{u} = \overrightarrow{H_1 H_2} \cdot \overrightarrow{v} = 0
\end{equation}
Given that
$$\begin{array}{r@{\;=\;}l}
\overrightarrow{H_1 H_2} & M + k_2 \overrightarrow{v} - V - k_1 \overrightarrow{u} \\
& \overrightarrow{VM} + k_2 \overrightarrow{v} - k_1 \overrightarrow{u} \\
& -\overrightarrow{\text{\tt diffc}} + k_2 \overrightarrow{v} - k_1 \overrightarrow{u} \\
\end{array}$$
we can re-write the system \eqref{Systeme} as
$$\left\{\begin{array}{r@{\;=\;}l@{\;=\;}l}
\overrightarrow{H_1 H_2} \cdot \overrightarrow{u} & -\overrightarrow{\text{\tt diffc}} \cdot \overrightarrow{u} + k_2 \overrightarrow{v} \cdot \overrightarrow{u} - k_1 \overrightarrow{u} \cdot \overrightarrow{u} & 0 \\
\overrightarrow{H_1 H_2} \cdot \overrightarrow{v} & -\overrightarrow{\text{\tt diffc}} \cdot \overrightarrow{v} + k_2 \overrightarrow{v} \cdot \overrightarrow{v} - k_1 \overrightarrow{u} \cdot \overrightarrow{v} & 0 \\
\end{array}\right.$$
which can also be written as
$$\left\{\begin{array}{r@{\;=\;}l}
-\overrightarrow{\text{\tt diffc}} \cdot \overrightarrow{u} + k_2 \cos(\overrightarrow{v},\overrightarrow{u}) - k_1 & 0 \\
-\overrightarrow{\text{\tt diffc}} \cdot \overrightarrow{v} + k_2 - k_1 \cos(\overrightarrow{u},\overrightarrow{v}) & 0 \\
\end{array}\right.$$
because $\|\overrightarrow{u}\| = \|\overrightarrow{v}\| = 1$.\\
Solving this system, we obtain :
$$\left\{\begin{array}{r@{\;=\;}l}
 k_1 & \frac{\strut -\overrightarrow{\text{\tt diffc}} \cdot (\overrightarrow{v}\cos(\overrightarrow{u},\overrightarrow{v}) - \overrightarrow{u})}{\strut \cos^2 (\overrightarrow{u},\overrightarrow{v}) - 1} \\
k_2	& \frac{\strut \overrightarrow{\text{\tt diffc}} \cdot (\overrightarrow{u}\cos(\overrightarrow{u},\overrightarrow{v}) - \overrightarrow{v})}{\strut \cos^2 (\overrightarrow{u},\overrightarrow{v}) - 1} \\
\end{array}\right.$$
In the code, {\tt s2} is calculated as :\\
{\tt s2 = (dpV0.X dv0dotdb - pBach.X) diffc.X + (dpV0.Y dv0dotdb - pBach.Y) diffc.Y + (dpV0.Z dv0dotdb - pBach.Z) diffc.Z;}\\
{\tt s2 = s2/denom;}\\
which can be written as\footnote{Given that $\text{\tt dv0dotdb} = \overrightarrow{\text{\tt dpV0}} \cdot \overrightarrow{\text{\tt pBach}} = \cos (\overrightarrow{\text{\tt dpV0}},\overrightarrow{\text{\tt pBach}})$. Thus $\text{\tt denom} = \cos^2 (\overrightarrow{\text{\tt dpV0}},\overrightarrow{\text{\tt pBach}}) -1 = \cos^2 (\overrightarrow{u},\overrightarrow{v}) - 1$.} :
$$\begin{array}{r@{\;=\;}l}
\text{\tt s2} & \frac{\strut (\overrightarrow{\text{\tt dpV0}} \cos(\overrightarrow{u},\overrightarrow{v}) - \overrightarrow{\text{\tt pBach}}) \cdot \overrightarrow{\text{\tt diffc}}}{\strut \cos^2 (\overrightarrow{u},\overrightarrow{v}) - 1} \\
 & \frac{\strut \overrightarrow{\text{\tt diffc}} \cdot (\overrightarrow{u} \cos(\overrightarrow{u},\overrightarrow{v}) - \overrightarrow{v})}{\strut \cos^2 (\overrightarrow{u},\overrightarrow{v}) - 1} \\
	& k_2 \\
\end{array}$$
So {\tt s2} is the 3-D algebraic distance $\overline{MH_2}$ between $M$ and $H_2$, the point of $\mathcal D$ that is closest to $\Delta$.

Then, {\tt valid} is calculated as $\left|\text{\tt s2} \sqrt{\text{\tt pBach.X}^2 + \text{\tt pBach.Y}^2}\right|$, i.e. it's the distance in the $(xOy)$ plane between $M$ and $H_2$, as illustrated by figure \ref{calcFig2}. The value {\tt valid} itself is not very helpful to determine if the linearisation is a good approximation or not. The value that has to be looked at is actually the distance between $H_2$ and the circle in the 2-D plane, which is called $d$ in figure \ref{calcFig2}.

But $d$ actually depends explicitely on {\tt valid}, which means that an initial requirement on $d$ can be transformed into a requirement on {\tt valid}. This allows not to calculate $d$ and saves some calculation time -- at least it's the only reason I've found that would explain why the authors of the code have chosen to test {\tt valid} rather than $d$ ! The relation between $d$ and {\tt valid} is :
$$d = \sqrt{R^2 + \text{\tt valid}^2} - R$$
\begin{equation}\label{dVsValid}
\Leftrightarrow \quad \frac{d}{R} = \sqrt{1+\left(\frac{\text{\tt valid}}{R}\right)^2\:} - 1
\end{equation}

There are 2 conditions on $\frac{\text{\tt valid}}{R}$. Let's call these two values $valid_1$ and $valid_2$, with $valid_1 < valid_2$. The original algorithm (I may change that, and will try to update this documentation if so) throws away any Xi candidate for which $\text{\tt valid} > valid_2$, and keeps all the other ones. But if $\text{\tt valid} \in [valid_1 ; valid_2]$, then another part of the algorithm, which I describe in the next paragraph, is run. It consists in improving the quality of the linearisation by linearising the helix at another point. This improvement is tried at most 3 times. Basically, this means that a linearisation that gives $\text{\tt valid} > valid_2$ means that it's hopelessly bad ; when $\text{\tt valid} < valid_1$ it means that the linearisation is good enough and doesn't need to be improved ; and when $\text{\tt valid} \in [valid_1 ; valid_2]$, the linearisation is improved but it actually doesn't matter if the criterium $\text{\tt valid} < valid_1$ is not reached : the candidate is kept anyway. As far as I've seen during the tests, only a very few proportion of the candidates need 3 passes in the loop\footnote{Result obtained over 1 {\tt Au}-{\tt Au} $200~GeV$ central event : over 73 269 bachelor, neglecting those which have only 1 intersection point, 45 500 have 2 intersection points, i.e. 62 \% of them (and therefore 38 \% have no intersection points). Among the 118 194 dca calculations of those 62 \%, 77.0 \% of them don't need a better linearisation, 21.7 \% need to go once in the loop, 0.8 \% need to go twice in the loop, and 0.5 \% go 3 times in the loop (this latter percentage, unike the former ones, is the number of candidates that need only 3 passes added to the number of candidates that would need more).}, so requiring more than 3 passes is indeed not necessary.

\begin{center}
\begin{tabular}{lc}
% Il sait pas wrapper !! Pour le faire, il faut charger le package multirow, mais je peux pas utiliser de package pour cette doc...
% Et en plus je suis oblige de mettre dans un tableau, ligne par ligne, sinon il met le tableau de la 2e partie aligne avec la 3e ligne de texte... Je pourrais me demerder avec une box, mais c'est chiant et pas propre non plus...
\begin{tabular}{l}
This table shows the numerical values of $valid_1$ and $valid_2$ \\
used in the code (first line) and their equivalent for the more \\
interesting variable $\frac{d}{R}$, calculated with \eqref{dVsValid}.\\
\end{tabular}
&
\begin{tabular}{r@{~$<$~}c@{~$<$~}l}
$0.001~R$ & {\tt valid} & $0.02~R$ \\
$5.10^{-7}~R$ & $d$ & $2.10^{-4}~R$ \\
0.0005 \% & $\frac{d}{R}$ & 0.02 \% \\
\end{tabular}
\\
\end{tabular}
\end{center}

\begin{center}

\epsfig{file=calcFig2.eps,width=11cm}

\mycaption{2-D plane evaluation of the quality of the approximation made by linearising the helix}
\label{calcFig2}
\end{center}

So when $\text{\tt valid} \in [valid_1 ; valid_2]$, here is the piece of code that is run :
\begin{maliste}
\item Former subroutine {\tt ev0\_project\_track} : calculates the coordinates (in the $(xOy)$ plane) of the point $M'$ defined as the intersection of the circle $\mathcal C$ and the line $(CH_2)$ (see {\sc Fig.} \ref{calcFig2})
\item Former subroutine {\tt update\_track\_param} : moves the origin of the helix from $M$ to $M'$ (as previously done from $A$ to $M$)
\item Former subroutine {\tt track\_mom} : calculates the momentum of the bachelor in $M'$ (as previously done in $M$)
\item Block that calculates {\tt s2} and {\tt valid} : calculates a new {\tt s2} and {\tt valid}, whose value will be checked to see if one more pass in this loop is necessary
\end{maliste}
The 3 last blocks are exactly the same as those already described above, so I'll only describe the former subroutine {\tt ev0\_project\_track} : the list below is made of the variables that are used in this area of the code :
\begin{maliste}
\item {\tt batv} : 3-D coordinates of $H_2$
\item {\tt dtmp} : $x_{_C} - x_{_{H_2}}$
\item {\tt atmp} : $y_{_C} - y_{_{H_2}}$
\item {\tt ctmp} : slope of the line $(CH_2)$
\item {\tt yy} : $y_{_{M'}} - y_{_C}$
\item {\tt zz} : $x_{_{M'}} - x_{_C}$
\item {\tt xAns} : temporary variable that I'll remove soon...
\item {\tt yAns} : temporary variable that I'll remove soon...
\item {\tt xOut} : $x_{_{M'}}$ (contained $x_{_M}$ before)
\item {\tt yOut} : $y_{_{M'}}$ (contained $y_{_M}$ before)
\end{maliste}
The calculation of $(x_{_{M'}},y_{_{M'}})$ is simple : since $\text{\tt ctmp} = \frac{x_{_C} - x_{_{H_2}}}{y_{_C} - y_{_{H_2}}}$ is the inverse of the slope of $(CH_2)$ the equation of $(CH_2)$ is :
$$(CH_2) : y = \frac{1}{\text{\tt ctmp}}(x - x_{_C}) + y_{_C}$$
and therefore, setting $x' = x_{_{M'}} - x_{_C}$ and $y' = y_{_{M'}} - y_{_C}$, $M'$ is such as :
$$\left\{\begin{array}{l}
y' = \left(\frac{1}{\text{\tt ctmp}}\right)x' \\
{x'\strut }^2 + {y'\strut }^2 = R^2 \\
% strut pour separer un peu mieux les 2 lignes du systeme, et accolades obligatoires pour x'^2 car il accepte pas un ^ juste apres un ^ (il considere que c'est 2 superscripts).
\end{array}\right.$$
Solving this system gives :
$$\left\{\begin{array}{r@{\;=\;}l}
y' & \pm \frac{R}{\sqrt{1+\text{\tt ctmp}^2}} \\
x' & \text{\tt ctmp}\cdot y' \\
\end{array}\right.$$
$x'$ and $y'$ are respectively {\tt zz} and {\tt yy} in the code, and the ``signus dilemma" is solved by the if-loop on the sign of {\tt atmp}.

At the end of the while-loop, the candidates for which $\text{\tt valid} > valid_2$ are simply thrown away, and all the other ones are kept, even if $\text{\tt valid} > valid_1$. The value of {\tt s2} calculated during the last loop is kept, and {\tt s1} (which is the $k_1$ of equation \eqref{k1k2} (p. \pageref{k1k2}) and of the following ones) is calculated as
$$\text{\tt s1} = \frac{-\overrightarrow{\text{\tt diffc}} \cdot (\overrightarrow{\text{\tt pBach}} \times \text{\tt dv0dotdb} - \overrightarrow{\text{\tt dpV0}})}{\text{\tt dv0dotdb}^2 - 1} = \frac{-\overrightarrow{\text{\tt diffc}} \cdot (\overrightarrow{v}\cos(\overrightarrow{u},\overrightarrow{v}) - \overrightarrow{u})}{\cos^2(\overrightarrow{u},\overrightarrow{v}) - 1} = k_1$$
Then, the 3-D coordinates of $H_1$ are calculated and stored in {\tt v0atv}, just like the coordinates of $H_2$ are stored in {\tt batv}. Once this is done, we check that $\overrightarrow{H_1 V}$ goes roughly in the same direction as $\overrightarrow{p_{_{V0}}}$, i.e. that the V0 points away from the Xi vertex newly found. This is done via the variable {\tt check}, that is exactly $\overrightarrow{H_1 V} \cdot \overrightarrow{p_{_{V0}}}$.

If {\tt check} is positive, it means that the V0 points to the opposite direction than where the Xi vertex is, and the rest of the algorithm -- run only in that case -- can be roughly summed up as something that looks like that :

$$
\begin{array}{|ll|}
\hline
\hspace{4pt}~ &

\hspace{-10pt}
\begin{tabular}{l}
{\tt dca} = $\left\|\overrightarrow{\text{\tt v0atv} - \text{\tt batv}}\right\|$ \hspace{55pt} {\tt // }{\tt dca} = $H_1 H_2$ \\
{\tt xpp} = $\frac{\text{\tt v0atv} - \text{\tt batv}}{2}$ \hspace{85pt} {\tt // }{\tt xpp} = 3-D coordinates of the middle of $[H_1 H_2]$ \\
{\tt rv} = $\left\|\overrightarrow{\text{\tt xpp} - \text{\tt xPvx}}\right\|$ \hspace{72pt} {\tt // }{\tt rv} = Xi decay length \\
if (cuts are OK) \\
\end{tabular} \\

\hspace{4pt}~ &
\left \lfloor
\begin{array}{l}

\hspace{-10pt}
\begin{tabular}{l}
{\tt pXi} = {\tt pV0} + {\tt xOrig} \hspace{58pt} {\tt // }$\overrightarrow{p_{_{Xi}}} = \overrightarrow{p_{_{V0}}} + \overrightarrow{p_{_{Bach,H_2}}}$\\
{\tt check} = ({\tt xpp} - {\tt xPvx}) . $\overrightarrow{\text{\tt pXi}}$ \hspace{20pt} {\tt // }Check that $\overrightarrow{PvxXivtx} \cdot \overrightarrow{p_{_{Xi}}} \geq 0$, i.e. that the \\
if ({\tt check} $\geq$ 0) \hspace{84pt} {\tt // } \hspace{20pt} reconstructed Xi points away from the Pvx \\
\end{tabular} \\

\left \lfloor
\begin{tabular}{l}
{\tt iflag}=0 if the dcaXiPvx (cut) is OK \\
\end{tabular}
\right. \\

\hspace{-10pt}
\begin{tabular}{l}
if ({\tt iflag}=0) \\
\end{tabular} \\

\left \lfloor
\begin{tabular}{l}
Calculates the kinematic variables \\
Store the candidate \\
\end{tabular}
\right. \\

\vspace{-12pt}
\end{array}
\right. \\
\hline
\end{array}
$$









\subsubsection{Detailed algorithm and cuts}

The detailed algorithm is actually explained in the paragraph \ref{paragrDca} concerning the calculation of the dca, p. \pageref{paragrDca}. Yet, in the latter paragraph, no overview of the algorithm is given and the cuts are not listed. This is the purpose of this short paragraph, and is summed up in {\sc Fig}. \ref{XiAlgoMieux}.

Blablabla.


\begin{center}

$
\begin{array}{|ll|}
\hline
\hspace{4pt}~ &
\hspace{-10pt} \begin{tabular}{l} {\bf Loop} over V0 vertices \\ \end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\begin{array}{l}
\hspace{-10pt} \begin{tabular}{l} Apply cuts on the V0 and V0 daughters \\ {\bf Loop} over global tracks \\ \end{tabular} \\
\left \lfloor
\begin{tabular}{l}
{\bf If} {\em track has wrong charge} : next \\
{\bf If} {\em track already used in the V0} : next \\
Find {\sc dca} between V0's straight line and track's helix \\
Apply cuts \\
{\bf If} {\em good candidate} : store \\
\end{tabular}
\right. \\
\vspace{-12pt}
\end{array}
\right. \\
\hline
\end{array}
$

\mycaption{Algorithm of the XiFinder}
\label{XiAlgoMieux}

\end{center}



\subsubsection{Detectors}

Blablabla




\vspace{1cm}

\section{Tests}

Blabla.


%Essai avec Dav' de mettre une equation numerotee a gauche : pas moyen !! On dirait qu'on est obliges d'utiliser eqnaray pour numeroter une equation, et eqnarray centre systematiquement, quoi qu'on lui fasse. On ne peut meme pas l'utiliser dans un tableau ni dans une array. Pas plus que l'environnement equationarray (package eqnarray). La FAQ parle de la commande \lefteqn qui s'utilise avec eqnarray, mais sans expliquer comment elle marche. En mettant fleqn dans les options de documentclass, ca marche mais ca le fait pour toutes les equations du document (meme si on utilie \mathindent comme {\parindent blabla}).
%%$\begin{array}{cc}
%%a & b \\
%%c & d \\
%%\end{array}$
%%
%%
%%\begin{eqnarray}
%%a=b
%%\end{eqnarray}
%%
%%{%\mathindent=1cm
%%
%%
%%
%%\begin{eqnarray}
%%a=b
%%\end{eqnarray}
%%
%%}
%%
%%
%%\begin{eqnarray}
%%a=b
%%\end{eqnarray}
%%
%%
%%\begin{flushleft}
%%$\begin{array}{c}
%%x=y
%%\end{array}$
%%\end{flushleft}
%%
%%Ici c'est moi.
%%
%%\lefteqn{
%%\begin{eqnarray}
%%a = b
%%\end{eqnarray}}
%
%\begin{eqnarray}
%x=y
%\end{eqnarray}
%
%\hspace{50pt}
%\begin{eqnarray}
%a=b
%\end{eqnarray}
%
%
%%\begin{flushleft}
%%\hspace{50pt}
%%\begin{alignat}{1}
%%a = b \\
%%c = d
%%\end{alignat}
%%\end{flushleft}
%
%%$\begin{array}{l}
%%\begin{array}{c}
%%$$x=y$$
%%\end{array} \\ 
%%\begin{array}{c}
%%q=y
%%\end{array}
%%
%%\end{array}$
%
%
%\parbox{2cm}{
%\begin{eqnarray}
%%x = y \hfill a \\
%x = y \hspace{12cm} ~
%\end{eqnarray}
%}









\end{document}







