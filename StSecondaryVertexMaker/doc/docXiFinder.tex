\documentclass[11pt,a4paper]{article}
\usepackage{a4,graphicx,color}
\usepackage{footnpag,array}
\usepackage{fancyhdr,fancybox}
\usepackage{amsmath}
\usepackage{french}

\oddsidemargin=-7mm
\textwidth=174mm
\addtolength{\headheight}{0.55cm}
\makeatletter
\def\@captype{figure}
\makeatother

\newenvironment{changemargin}[2]{\begin{list}{}{
\setlength{\topsep}{0pt}
\setlength{\leftmargin}{0pt}
\setlength{\rightmargin}{0pt}
\setlength{\listparindent}{\parindent}
\setlength{\itemindent}{\parindent}
\setlength{\parsep}{0pt plus 1pt}
\addtolength{\leftmargin}{#1}
\addtolength{\rightmargin}{#2}
}\item }{\end{list}}
\newcommand{\itemb}[1]{\setlength{\parindent}{-1cm}\begin{changemargin}{1cm}{0cm}#1\end{changemargin}\setlength{\parindent}{0cm}}

% Profondeur de \subsubsection = 3
\setcounter{tocdepth}{3}     % Dans la table des matieres
\setcounter{secnumdepth}{3}  % Avec un numero.

\begin{document}

\pagestyle{fancy}
\renewcommand{\sectionmark}[1]{\markboth{#1}{}}
\lhead{V0Finder and XiFinder}
\rhead{\leftmark}

%\discretionary{Avant la coupure}{après}{s'il n'y en a pas}
%\discretionary{}{-}{}
%

\parindent40pt

\begin{center}

~

\thispagestyle{empty}

\vspace{8cm}

{\Huge\bf XiFinder and V0Finder documentation}

\end{center}


\newpage


\section*{}
\addcontentsline{toc}{section}{Table of contents}
\tableofcontents
\vspace{2cm}
\section*{}
\addcontentsline{toc}{section}{List of figures}
\listoffigures

\thispagestyle{empty}


\newpage



\section{What are the V0Finder and XiFinder ?}

Let's first define the 3 different sorts of secondary vertices :
\begin{itemize}
\item Kink vertices : when a charged particle decays into a charged plus a neutral,
\item V0 vertices : when a neutral particle decays into two charged particles,
\item Xi vertices : when a charged particle decays into a charged plus a neutral, and then the neutral daughter decays itself into two charged particles. One can't say that a Xi vertex is a Kink followed by a V0, because both charged tracks (mother and daughter) have to be seen in the {\sc tpc} in order to say that the vertex is a kink. This is not the case for Xi vertices, because the $c\tau$ of particles who do a Xi vertex if much shorter than the distance between the primary vertex and the {\sc tpc} ($50~cm$), even shorter than the distance to the first layer of the {\sc svt} ($6.7~cm$, versus $c\tau_{_\Xi} = 4.9~cm$ and $c\tau_{_\Omega} = 2.5~cm$).
%c\tau__\Xi marche mais fait erreurs a la compilation.
\end{itemize}

People working on strange particles in the strangeness group need a piece of code that is able to reconstruct the primary strange particles from the tracks. Those strange particles can be divided into two groups :
\begin{itemize}
\item {\bf V0's :} those particles ($\Lambda$, $K^0_s$) decay into two particles ($\Lambda \longrightarrow p \pi^-$, $K^0_s \longrightarrow \pi^+ \pi^-$). We need to be able to search and find them using only the daughter's tracks (that's all we have !).
\item {\bf Xi's :} those particles ($\Xi$, $\Omega$) decay into 1 charged particle -- called bachelor -- and a $\Lambda$ ($\Xi \longrightarrow \Lambda \pi^-$, $\Omega \longrightarrow \Lambda K^-$). The $\Lambda$, as said in the previous item, decays into two particles. So here, we need to find all combinations of 3 charged particles that are possibly the daughters of a unique strange particle.
\end{itemize}
The algorithms of those codes are described in the section \ref{sec3}.

From the beginning of {\sc star} and until year 2002, the codes used were what I will call afterwards {\em exiam} and {\em ev0am}. They are Fortran codes, located in {\tt pams/global/exi/\-exiam.F} and {\tt pams/global/\-ev0/\-ev0\_am2.F}, with other files that are necessary for the code to be run (basically subroutines and interfacing functions).

So here is the ``old" way to do things : the {\sc bfc} is run, and it calls the series of makers that it is supposed to call. Among those makers are {\tt StXiMaker} and {\tt StV0Maker} -- the strangeness makers, with {\tt StKinkMaker} -- and they are run after nearly all the other makers of the {\sc bfc}, since they need the tracks to be reconstructed and the primary vertex to be found. The V0Maker is run first, finds the V0's, and those feed the XiMaker, which tries to find Xi candidates for each V0. At a deeper level, inside the {\tt Make()} function of both the XiMaker and the V0Maker, are called the Fortran {\sc pam}s, i.e. respectively {\tt ev0am} and {\tt exiam}. {\sc pam} means either ``Plugable Analysis Module" or ``Physics Analysis Module". I don't know if somebody knows which of the two it is !

The interfacing between the {\sc bfc} (C++) and the {\sc pam}s (Fortran) won't be discussed here. If you want to know more, you can have a look at those files : {\tt pams/global/exi/\-exiam.idl}, {\tt pams/global/\-ev0/\-ev0\_am2.idl}, {\tt pams/idl/dst\_track.idl}, {\tt pams/idl/\-dst\_\-vertex.idl}, {\tt pams/idl/\-dst\_\-v0\_\-vertex.\-idl}, {\tt pams/idl/dst\_xi\_vertex.idl}. The data are passed -- from maker to maker, and also between a maker and the {\sc pam} it calls -- by tables. For example the tracks are stored in a table, and ev0am will read the table to have the tracks parameters. It will then store the V0's in another table. Then, exiam will read this table and the table of tracks, and write the Xi's found in a third table. Classes for interfacing have a general name which is ``St\_tableName\_Table.h", and they can be found in {\tt include/tables/} (as examples : {\tt St\_exi\_exipar\_Table.h}, {\tt St\_ev0\_aux\_Table.h}, {\tt St\_dst\_track\_Table.h}, {\tt St\_dst\_xi\_vertex\_Table.h}, etc... Further information about St\_\-dst\_\-track\_Table can be found at {\tt root.cern.ch/root/html/TTable.html} in the section ``Class description"). On the other hand, the corresponding structures are stored in {\tt pams/\-global/idl/}, in files like {\tt exi\_exipar.idl} (general name of the file : tableName.idl ; general name of the structure used afterwards : tableName\_st). You could have a look at e.g. {\tt StXiMaker::Init()} (the V0 and XiMaker's are in {\tt StRoot/St\_dst\_Maker/}) to have an example of how all this is used.

As explained in the section \ref{sec2}, the strangeness Fortran {\sc pam}s had to be replaced with C++ code. As exiam and ev0am refer to the corresponding {\sc pam}s, {\em XiFinder} and {\em V0Finder} are the names we gave to their C++ translations. They are makers, whose complete names are {\tt StXiFinderMaker} and {\tt StV0FinderMaker}. This is what we call the {\em strangeness StSecondaryVertexMaker package}.




\vspace{1cm}

\section{Historical purpose for StSecondaryVertexMaker package}
\label{sec2}

The StSecondaryVertexMaker package implements secondary vertex-finding
in C++. {\em Why ?}
There is and has been code for reconstucting secondary vertices
in the form of the {\tt ev0}, {\tt exi}, and {\tt tkf} {\sc pam}s. These {\sc pam}s were
written in Fortran and work with tables. They are called from C++
makers currently kept in the St\_dst\_Maker package library.
They work well, but suffer limitations :
\begin{itemize}
\item They cannot be re-run on {\sc dst}s after production,
\item They cannot operate on the tracking output of {\sc ittf}.
\end{itemize}
In order to overcome both limitations, the preffered solution is
to write C++ versions of these {\sc pam}s which can use StEvent
structures for both input and output (versus trying to convert
StEvent structures back into tables for input). This is the primary
purpose of the StSecondaryVertexMaker package.

Advantages of being able to run such a code on the {\sc dst}s are that analysis such as rotating can be done without running the whole {\sc bfc} on the daq files, as well as analysis that require modifications in the secondary vertex reconstruction code, like the value of the reconstruction cuts for example. The time profit is huge, since it takes more than 20 times more time to run the whole reconstruction chain than just the C++ secondary vertex reconstruction makers.




\vspace{1cm}

\section{Overall algorithms of the codes}
\label{sec3}

Apart from some parts described below, the V0Finder and XiFinder are essentially the ev0 and exi {\sc pam}s rewritten from Fortran to C++, from a ``tabelized" way of communicating to a standard object-oriented, mono-language code.

\subsection{KinkFinder}

To be written.

\subsection{V0Finder}

Cut parameters are initially requested from the database (time stamps determine what is the nature of the data, e.g. {\tt p-p}, {\tt Au-Au},
{\tt d-Au}). Then, tracks which satisfy a set of cuts are chosen as candidates for V0 daughters. The daughter candidates are then examined in pairs of negative and positive daughters to see if the
tracks approach each other and pass a series of cuts to determine if they are consistent with a V0 secondary decay.

Formerly, a second pass was required on the V0s. This was to facilitate their use in finding Xi decays. V0s from Xi decays are {\em secondary} V0s, and thus do not originate from the primary
vertex. This means looser cuts are necessary on these V0s than {\em primary} V0s. So, the first pass was made with the loose cuts, the Xi decays were found, and then the V0s were run through
tighter cuts to remove unused ones which were inconsistent with being primary V0s. This second pass prevented the output of significant numbers of unnecessary V0 candidates.

This second pass has been replaced by a different mechanism. Now, for each V0 which passes the looser secondary V0 cuts, a {\tt UseV0()} function is called. The idea is that a XiFinder can be
written which inherits from the V0Finder, and implements the {\tt UseV0()} function to find Xi candidates with a given V0. The {\tt UseV0()} function then returns true or false depending on
whether any Xi candidates are found using that V0. Upon returning to the V0Finder code, the V0 is discarded if it neither passes the cuts for a primary V0 nor gets used in the {\tt UseV0()} function.

This scheme has the advantage of not inserting a V0 into the StEvent vector of V0s unless it is a viable candidate. It also reduces considerably the memory overhead required during
V0-finding as not all of the secondary V0 candidates are found and stored at once (particularly poignant in high-multiplicity events where many thousands of secondary V0s are
considered). This only disadvantage is some overhead in making a function call in the middle of the V0-finding loop.

{\sc Fig.} \ref{V0Algo} shows that even if the code of the V0Finder is quite long, the alorithm is definitely simple.

%\begin{flushleft}
%
%\begin{array}{l}
%{\bf Loop} over positive tracks \\
%\[
%\left \lfloor
%\begin{array}{l}
%{\bf Loop} over negative tracks \\
%%Debut sous-tableau
%\[
%\left \lfloor
%\begin{tabular}{l}
%Find {\sc dca} between both helices \\
%Apply cuts \\
%{\bf If} {\em good candidate} : store \\
%\end{tabular}
%\right.
%\]
%%Fin sous-tableau
%\end{array}
%\right.
%\]
%\end{array}
%
%\caption{Overall algorithm of the V0Finder}
%\label{V0Algo}
%
%\end{flushleft}

%Ca chie : ca produit le bon resultat, mais ca fait des erreurs a la compilation.

%$
%\left \lfloor
%\begin{array}{l}
%xy \\
%\left \lfloor
%\begin{array}{ccc}
%   x + y & = & 0 \\
%   x - y & = & 0
%\end{array}
%\right.
%\end{array}
%\right.
%$

%La raison est que il ne comprend pas \[ et \] en mode math, et justement \[ et \] mettent implicitement ce qui est a l'interieur en mode math ! (Enfin +/-...). L'exemple ci-dessus marche, mais moi je voudrais que l'interieur soit en mode texte, pour mettre du texte dedans... Enfin plutot c'est pas accepte dans l'environnement tabular, mais je n'ai rien d'autre pour faire des retours a la ligne ("\\" marche pas).

% OK : d'apres doc, \[ et \] sont raccourcis pour environnement displaymath, dont un autre raccourci est... $$...$$ !
% D'ailleurs, je suis etonne qu'il accepte tabular dans un mode Math !

%\begin{flushleft}
\begin{center}
%\mathversion{bold} 
%Marche pas (ca fait rien). Package amsmath.
$
%Avec $$...$$, il centre, meme dans le flushleft.
\begin{array}{c}
\begin{tabular}{|c|}
\hline
Container of tracks \\
\hline
\end{tabular} \\
%\boldsymbol{\downarrow} \\ %Ca marche (package amsmath)
%\boldsymbol{\Big \downarrow} \\ %Ca marche pas, ca fait une \Big \downarrow normale.
%\pmb{\downarrow} \\ %Ca marche (package amsmath) mais c'est putain de gras !! Et c'est moche.
\pmb{\Big \downarrow} \\ %Ca marche (package amsmath) mais c'est putain de gras !! (A peine moins que le precedent, plus que \boldsymbol{\downarrow}). Et c'est moche.
%\Big \downarrow \\
\begin{array}{|ll|}
\hline
\hspace{4pt}~ & % Pour eviter que soit colle contre le bord gauche.
% Mais il faut que le hspace soit suivi d'un caractere a sa droite (si a sa gauche, ca marche pas, car a sa droite est le bord de la colonne, donc il s'en fout). Par exemple "~" ou "\ " (les 2 marchent).
\hspace{-10pt} \begin{tabular}{l} {\bf Loop} over positive tracks \\ \end{tabular} \\
% Le hspace est necessaire, car le fait de faire un tableau decale le texte (le tableau est invisible).
\hspace{4pt}~ & % Pour eviter que soit colle contre le bord gauche.
\left \lfloor
\begin{array}{l}
%{\textstyle {\bf Loop} over negative tracks} \\
%Ca chie : aucune action.
%\textstyle{{\bf Loop} over negative tracks} \\
%Pas mieux. Donc methode bourrin...
\hspace{-10pt} \begin{tabular}{l} {\bf Loop} over negative tracks \\ \end{tabular} \\
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Find {\sc dca} between both helices \\
Apply cuts \\
{\bf If} {\em good candidate} : store \\
\end{tabular}
\right. \\
\vspace{-11pt}
%Le \\ sert a faire un ligne apres la fermuture du \lfloor. Mais il n'y a rien sur cette ligne, donc le \lfloor exterieur n'enveloppe toujours pas le \lfloor interieur jusqu'au bout. Si on ajout un \vspace, il ajoute une ligne entiere en plus du vspace. Il faut donc lui mettre un vspace negatif.
\end{array}
\right. \\
\hline
\end{array} \\
%\Big \downarrow \\
\pmb{\Big \downarrow} \\
\begin{tabular}{|c|}
\hline
Container of V0 vertices \\
\hline
\end{tabular} \\
\end{array}
$
\caption{Overall algorithm of the V0Finder.}
\label{V0Algo}

%\end{flushleft}
\end{center}



\subsection{XiFinder}

The {\tt StXiFinderMaker} inherits from {\tt StV0FinderMaker} as indicated above. Because it is actually a V0Finder itself via this inheritance, one need not instantiate a {\tt StV0FinderMaker} if one
instantiates a {\tt StXiFinderMaker}.

Similar to the {\tt StV0FinderMaker}, appropriate cut parameters are initially requested from the database. The same tracks that are considered for the V0s are also used as daughter candidates
for the Xis. The {\tt Make()} member function then simply calls the inherited {\tt Make()} member function from the {\tt StV0FinderMaker}. Control comes back to the {\tt StXiFinderMaker} at the call to
{\tt UseV0()}, which is implemented here as a loop over Xi daughter candidates to be paired with the V0 daughter candidate. If the daughters approach each other and pass a series of cuts, the
candidate is accepted and stored in StEvent. Control is then passed back to the V0Finder, with a return value indicating whether the V0 was in fact used.

As for the V0Finder, {\sc Fig.} \ref{XiAlgo} below shows that the XiFinder alorithm is very simple, although the code is long. More detailed algorithms can be found in section \ref{sec4}.

%\begin{flushleft}
\begin{center}

%\begin{tabular}{l}
%{\bf Loop} over V0 vertices \\
%\[
%\left \lfloor
%\begin{tabular}{l}
%Apply cuts on the V0 and V0 daughters \\
%{\bf Loop} over global tracks \\
%%Debut sous-tableau
%\[
%\left \lfloor
%\begin{tabular}{l}
%{\bf If} {\em track has wrong charge} : next \\
%{\bf If} {\em track already used in the V0} : next \\
%Find {\sc dca} between V0's straight line and track's helix \\
%Apply cuts \\
%{\bf If} {\em good candidate} : store \\
%\end{tabular}
%\right.
%\]
%%Fin sous-tableau
%\end{tabular}
%\right.
%\]
%\end{tabular}

$
\begin{array}{c}
\begin{tabular}{r|>{\centering}p{4.2cm}|>{\centering}p{4.2cm}|l}
\cline{2-3}
& Container of V0 vertices & Container of tracks & \\
\cline{2-3}
\end{tabular} \\
\pmb{\Big \downarrow} \\
\begin{array}{|ll|}
\hline
\hspace{4pt}~ &
\hspace{-10pt} \begin{tabular}{l} {\bf Loop} over V0 vertices \\ \end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\begin{array}{l}
\hspace{-10pt} \begin{tabular}{l} Apply cuts on the V0 and V0 daughters \\ {\bf Loop} over global tracks \\ \end{tabular} \\
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
{\bf If} {\em track has wrong charge} : next \\
{\bf If} {\em track already used in the V0} : next \\
Find {\sc dca} between V0's straight line and track's helix \\
Apply cuts \\
{\bf If} {\em good candidate} : store \\
\end{tabular}
\right. \\
\vspace{-12pt}
\end{array}
\right. \\
\hline
\end{array} \\
\pmb{\Big \downarrow} \\
\begin{tabular}{|c|}
\hline
Container of Xi vertices \\
\hline
\end{tabular} \\
\end{array}
$


\caption{Overall algorithm of the XiFinder.}
\label{XiAlgo}

%\end{flushleft}
\end{center}


%\begin{tabular}
%{|>{\raggedleft}p{1in}
% |>{\centering}p{1in}
%	|>{(\raggedright}p{1in}<{)}
%	|l|}
%\hline
%blabla & blabla & blabla & blabla \\
%\hline
%\end{tabular}
% Ca, ca marche. Mais des qu'on vire la 4e colonne, ca marche plus... Solution crade :
%\begin{tabular}
%{|>{\raggedleft}p{1in}
% |>{\centering}p{1in}
%	|>{(\raggedright}p{1in}<{)}
%	|l}
%\cline{1-3}
%blabla & blabla & blabla & \\
%\cline{1-3}
%\end{tabular}
%... que je vais implementer dans le tableau ci-dessus illico.









\vspace{1cm}

\section{Structure of the Fortran and C++ codes}
\label{sec4}

The first thing to mention is a change in the interaction between the V0Finder and the XiFinder. The XiFinder actually uses the V0's that have first been found by the V0Finder. The table below shows how this is done in the Fortran code :

\begin{center}
\begin{tabular}{|l|l|}
\hline
Call {\tt StV0Maker::Make()} & Finds V0's and store them in a table \\
Call {\tt StXiMaker::Make()} & Loop over the V0's in the table to find Xi candidates \\
Call {\tt StV0Maker::Trim()} & Loop over the V0's in the table to throw away the \\
&  non-primary V0's that are not used in a Xi candidate \\
\hline
\end{tabular}
\end{center}

This waste of memory (storing V0's that will be deleted afterwards) and of time (scanning twice the table of V0's) is solved in the C++ code, by the fact that the class {\tt StXiFinderMaker} actually inherits from {\tt StV0FinderMaker}. The member-functions of each of them and their role are listed in {\sc Fig}. \ref{fonctions-membres}.

Note that {\tt StXiFinderMaker::Init()} is the equivalent of {\tt StV0FinderMaker::GetPars()}. The effect of the function {\tt StV0FinderMaker::DontZapV0s} is that the V0's that are already in StEvent are kept, the V0's found by the V0Finder will be added. The function {\tt StV0FinderMaker::UseExistingV0s} also keeps the V0's that are already in StEvent, but also prevents the V0Finder to be run, and forces the XiFinder to use the V0's previously found. The function {\tt StV0FinderMaker::UseITTFTracks} has been implemented for {\sc ittf} test purposes, since it allows the user to choose between using the {\sc ittf} tracks or using the tracks found by the standard reconstruction.

When the V0Finder is run alone, the method {\tt StV0FinderMaker::UseV0()} is called for each V0 found, and returns {\tt false}, since we don't want to find Xi's.

When both the XiFinder and V0Finder are run, the XiFinder first calls {\tt StV0FinderMaker::Make()}. This function finds V0's and, for each of them, calls the {\tt UseV0()} method. The latter runs the XiFinder algorithm, that will eventually tell {\tt StV0FinderMaker::Make()} if the current V0 has been used in Xi candidates or not. This way to do, compared with the Fortran one, saves time and memory.

\begin{center}
\begin{tabular}{|r|l|l|}
\hline
Function & Role in the V0Finder & Role in the XiFinder \\
\hline
\hline
{\tt Init} & Inits & Gets {\tt exipar} from the database \\
\hline
{\tt Make} & V0Finder ``central" algorithm & Calls the V0Finder \\
\hline
{\tt Clear} & Clears & Not redefined \\
\hline
{\tt GetPars} & Gets {\tt ev0par2} from the database & Not redefined (not used) \\
\hline
{\tt Prepare} & Finds event-wise parameters, fills tables & Not redefined \\
\hline
{\tt UseV0} & Returns {\tt false} & XiFinder ``central" algorithm \\
\hline
{\tt UseExistingV0s} & Sets a boolean flag & Not redefined \\
\hline
{\tt DontZapV0s} & Sets a boolean flag & Not redefined \\
\hline
{\tt UseITTFTracks} & Sets a boolean flag & Not redefined \\
\hline
{\tt UsingITTFTracks} & Returns a boolean flag & Not redefined \\
\hline
{\tt Trim} & Remove the V0's that don't pass cuts & Not redefined (not used) \\
\hline
\end{tabular}
\caption{Member-functions of {\tt StV0FinderMaker} and {\tt StXiFinderMaker}.}
\label{fonctions-membres}

\end{center}

The table below shows how this is run in the C++ XiFinder (provided that it's the XiFinder that is called and not just the V0Finder) :

\begin{center}
\begin{tabular}{|l|l|}
\hline
Call {\tt StXiFinderMaker::Make()} & (Calls everything below) \\
~~~~ Call {\tt StXiFinderMaker::Prepare()} & Finds event-wise parameters and fills the tables \\
~~~~ Call {\tt StV0FinderMaker::Make()} & Finds V0's in this event \\
~~~~~~~~~ Call {\tt StXiFinder::UseV0()} & Finds Xi's for a given V0 and store them in StEvent \\
~~~~ (back in {\tt V0FinderMaker::Make}) & If V0 is used in Xi's / may be primary : store in StEvent \\
\hline
\end{tabular}
\end{center}



\subsection{KinkFinder}

To be written.


\subsection{V0Finder}

{\sc Fig}. \ref{V0AlgoMieux} shows the detailed structure of the V0Finder, with all the cuts that are applied. Of course, more accurate information can be found... by looking at the code ;-)~.

Before the loops, tables called {\tt ptrks}, {\tt ntrks}, etc..., are filled in the function {\tt StV0FinderMaker::Prepare()}, and the values used afterwards are those that are stored in these tables, in order to improve the speed of the code. The XiFinder doesn't use them yet... but will.

The cuts' value are got in the function {\tt StV0FinderMaker::GetPars()}, and stored in the member objects {\tt pars} and {\tt pars2}. Here are the components :
\begin{itemize}
\item {\tt n\_point} : number of hits,
\item {\tt dcapnmin} : distance of closest approach between the daughter tracks and the primary vertex,
\item {\tt dca} : distance of closest approach between the V0 daughters,
\item {\tt dlen} : decay length of the V0,
\item {\tt dcav0} : distance of closest approach between the V0 trajectory and the primary vertex,
\item {\tt alpha\_max} : $\alpha$ Armanteros,
\item {\tt ptarm\_max} : $p_\perp$ Armanteros.
\end{itemize}

\begin{center}
$
\begin{array}{|ll|}
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
Get parameters from database \\
Get event \\
Get position of the primary vertex \\
{\bf Loop} over all tracks \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Select normal vs {\sc ittf} \\
{\bf If} {\it bad flag} : next \\
{\bf If} {\it bad detector {\sc id}} : next \\
Store track and parameters in tables \\
%\hspace{1cm} (separately pos. and neg.) \\
\hfill (separately pos. and neg.) \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf Loop} over positive tracks \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\begin{array}{l}
\hspace{-10pt} \begin{tabular}{l} {\bf Loop} over negative tracks \\ \end{tabular} \\
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Determine V0's detector {\sc id} \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on number of hits \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on dcaTrackToPvx \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on $p_\perp$ \\
Find number of intersection points between both helices \\
Find 2D dca between both helices at both intersection points\\
Keep the smallest dca \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} if one track points away from Pvx \\
Calulate approximated 3D dca between both helices \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on dcaV0Daughters \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} ..............\\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on decay length from Pvx \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} if V0 points away from Pvx \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on dcaV0ToPvx \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on $\alpha_{Arm}$ \\
{\footnotesize\bf CUT \hspace{-30pt} CUT} on $p_{\perp_{Arm}}$ \\
Fill an {\tt StV0Vertex} \\
Call {\tt UseV0} to find if V0 is used for Xis \\
{\bf If} {\it primary or used in Xi} : store \\
\end{tabular}
\right. \\
\vspace{-11pt}
\end{array}
\right. \\
%\hspace{4pt}~ & \vspace{-10pt} \\
%Ca fait bien remonter la hline, mais pas les 2 bords verticaux du tableau ! Du coup, la fin de l'"accolade" exterieure touche un peu la ligne du bas du tableau (hline), mais tant pis.
\hline
\end{array}
$
\caption{Algorithm of the V0Finder.}
\label{V0AlgoMieux}

\end{center}




\subsection{XiFinder}

The differences between the Fortran code and the C++ code are shown in {\sc Fig}. \ref{XiFC}, on the half-detailed algorithm. The red lines show what has disappeared, either because of the new structure of the code, or because of the fact that we are using StEvent. The green lines show the parts that have been reshaped, for the same reasons as several parts have been removed.

Apart from these modifications, the code is a simple translation from Fortran to C++. This may change once we are convinced that the C++ code has no bug : we may then want to have the code more readable, or better organised, or we may even want to replace some calculation algorithms.

So far, the code is all in one block, for speed purposes, and the beginning and end of each former Fortran subroutine is indicated by commented lines. Once again, when we are sure that we don't need to compare the C++ and Fortran codes anymore, we'll probably remove all this.

Avoiding calls to subfunctions resulted in a duplication of a certain part of the code. Figure \ref{blocs} show how the C++ code structure fits to the Fortran one, but let's detail the changes (green lines in {\sc Fig}. \ref{XiFC}) one by one.




\begin{center}

$
\begin{array}{cc}
\begin{array}{|ll|}                 %Debut array 0
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
Do things... \\
{\bf Loop} over V0 vertices \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor                       %Accolade 1
\begin{array}{l}                    %Debut array 1
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 1
\textcolor{red}{Find vertex key} \\
Hits in which detectors \\
\textcolor{green}{Lambda mass checks, cuts} \\
{\bf Loop} over global tracks \\
\end{tabular} \\                    %Fin tableau 1
\left \lfloor                       %Accolade 2
\begin{array}{l}                    %Debut array 2
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 2
Select correct charge \\
Don't use V0 tracks \\
Hits in which detectors \\
\textcolor{red}{Parameters conversion} \\
\textcolor{red}{Subroutine {\tt circle\_param}} \\
Calculate dca V0/bachelor in 2D \\
\textcolor{green}{Subroutine {\tt casc\_geom}} \\
\textcolor{green}{{\bf Loop} over the 2 intersect. points} \\
\end{tabular} \\                       %Fin tableau 2
\left \lfloor                       %Accolade 3
\hspace{-4pt}
\begin{tabular}{l}                  %Debut tableau 3
Subroutine {\tt update\_track\_param} \\
Approxim. of 3D-dca by lineari- \\
\hfill zation of the helix \\
\textcolor{red}{Subroutine {\tt track\_mom}} \\
Check validity of linear approx. \\
Subroutine {\tt ev0\_project\_track} \\
{\bf If} {\em not good} : try again (up to 3 \\
\hfill tries) \\
\textcolor{green}{{\bf If} {\em cuts OK} : fill table} \\
\end{tabular}                       %Fin tableau 3
\right. \\                          %Accolade 3
\vspace{-12pt}
\end{array}                         %Fin array 2
\right. \\                          %Accolade 2
\vspace{-12pt}
\end{array}                         %Fin array 1
\right. \\                          %Accolade 1
\hline
\end{array}                         %Fin array 0
&
\begin{array}{|ll|}                 %Debut array 0
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
Do things... \\
{\bf Loop} over V0 vertices \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor                       %Accolade 1
\begin{array}{l}                    %Debut array 1
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 1
~ \\
Hits in which detectors \\
\textcolor{green}{Lambda mass checks, cuts} \\
{\bf Loop} over global tracks \\
\end{tabular} \\                    %Fin tableau 1
\left \lfloor                       %Accolade 2
\begin{array}{l}                    %Debut array 2
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 2
Select correct charge \\
Don't use V0 tracks \\
Hits in which detectors \\
~ \\
~ \\
Calculate dca V0/bachelor in 2D \\
\textcolor{green}{Subroutine {\tt casc\_geom}} \\
\textcolor{green}{{\bf Loop} over the 2 intersect. points} \\
\end{tabular} \\                       %Fin tableau 2
\left \lfloor                       %Accolade 3
\hspace{-4pt}
\begin{tabular}{l}                  %Debut tableau 3
Subroutine {\tt update\_track\_param} \\
Approxim. of 3D-dca by lineari- \\
\hfill zation of the helix \\
~ \\
Check validity of linear approx. \\
Subroutine {\tt ev0\_project\_track} \\
{\bf If} {\em not good} : try again (up to 3 \\
\hfill tries) \\
\textcolor{green}{{\bf If} {\em cuts OK} : fill StEvent} \\
\end{tabular}                       %Fin tableau 3
\right. \\                          %Accolade 3
\vspace{-12pt}
\end{array}                         %Fin array 2
\right. \\                          %Accolade 2
\vspace{-12pt}
\end{array}                         %Fin array 1
\right. \\                          %Accolade 1
\hline
\end{array}                         %Fin array 0
\end{array}
$

\caption{Algorithm of the XiFinder.}
\label{XiFC}

\end{center}


The reshaping of the Lambda mass calculation consisted simply in calculating the invariant mass using other parameters : taking the example of the $\Lambda$ invariant mass, we have :
$$
\begin{array}{r@{~=~}l}
m^2_\Lambda & E^2_\Lambda - \overrightarrow{p}^2_\Lambda \\
& (E_++E_-)^2 - (\overrightarrow{p}_++\overrightarrow{p}_-)^2 \\
& E^2_+ + E^2_- + 2E_+E_- - \overrightarrow{p}^2_+ - \overrightarrow{p}^2_- - 2\overrightarrow{p}_+\overrightarrow{p}_- \\
\end{array}
$$
In Fortran, the $E$ and $\overrightarrow{p}$ terms are grouped together, and the invariant mass is calculated with this formula :
$$m^2_\Lambda = m^2_p + m^2_\pi + 2E_+E_- - 2\overrightarrow{p}_+\overrightarrow{p}_-$$
In C++, energies and momenta are kept separated, and the formula used is, as already written above :
$$
\begin{array}{r@{~=~}l}
m^2_\Lambda & (E_++E_-)^2 - (\overrightarrow{p}_++\overrightarrow{p}_-)^2 \\
& \left(\sqrt{\overrightarrow{p}^2_++m^2_p} + \sqrt{\overrightarrow{p}^2_-+m^2_\pi}\right)^2 - \overrightarrow{p}^2_\Lambda \\
\end{array}
$$


To modify the structure of {\em casc\_geom} and of the loop coloured in green in {\sc Fig}. \ref{XiFC}, I've written the Fortran code as a set of for-loops, if-loops, goto's and blocks of instructions. The figures below show those reashapings : {\sc Fig}. \ref{cascgeom} shows the reshaping of {\em casc\_geom}, and {\sc Fig}. \ref{blocs} shows the reshaping of the inside of the loop over the intersection points (between the bachelor's helix and the V0's straight line). In {\sc Fig}. \ref{blocs}, what is called {\em Block 5} is actually a huge part of the program, in it hasn't been reshaped.

\begin{center}
$
\begin{array}{ccc}
\begin{array}{|ll|}                   %Debut array 0
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf if} ($p_x \ne 0$) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 1 \\
{\bf if} ($c < 0$) {\bf goto} 137 \\
Block 2 \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf else} ~~{\tt //}($p_x == 0$) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 3 \\
{\bf if} ($c < 0$) {\bf goto} 137 \\
Block 4 \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf exit} ~~{\tt //}(from the subroutine) \\
\end{tabular} \\

\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf Lbl} 137 \\
{\bf if} ($p_x \ne 0$) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 5 \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf else} ~~{\tt //}($p_x == 0$) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 6 \\
\end{tabular}
\right. \\
\hline
\end{array}                           % Fin array 0

&
\Longrightarrow\hspace{-18pt}\Longrightarrow
&

\begin{array}{|ll|}                   %Debut array 0
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf if} ($p_x \ne 0$) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 1 \\
{\bf if} ($c < 0$) Block 5 \\
~~~ {\bf else} Block 2 \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf else} ~~{\tt //}($p_x == 0$) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 3 \\
{\bf if} ($c < 0$) Block 6 \\
~~~ {\bf else} Block 4 \\
\end{tabular}
\right. \\
\hline
\end{array}                           % Fin array 0
\end{array}
$
\caption{Reshaping of {\tt casc\_geom} : Fortran to C++.}
\label{cascgeom}

\end{center}

\begin{center}

$
\begin{array}{ccc}
\begin{array}{|ll|}                 %Debut array 0
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\tt tries=1} \\
Block 1 \\
{\bf Lbl} 60 \\
Block 2 \\
{\bf if} ({\tt cond1} \&\& {\tt tries$\le$3}) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor                       %Accolade 1
\begin{array}{l}                    %Debut array 1
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 1
Block 3 \\
{\bf if} ({\tt cond2}) ~~{\tt //}(Depends on Block 2)\\
\end{tabular} \\                    %Fin tableau 1
\left \lfloor                       %Accolade 2
\begin{array}{l}                    %Debut array 2
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 2
{\tt tries++} \\
Block 4 \\
{\bf Goto} 60 \\
\end{tabular} \\                       %Fin tableau 2
\vspace{-12pt}
\end{array}                         %Fin array 2
\right. \\                          %Accolade 2
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 1
Block 5 \\
\end{tabular} \\                    %Fin tableau 1
\vspace{-12pt}
\end{array}                         %Fin array 1
\right. \\                          %Accolade 1
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf if} ({\tt cond3}) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor                       %Accolade 1
\begin{array}{l}                    %Debut array 1
\hspace{-10pt}
\begin{tabular}{l}                  %Debut tableau 1
{\bf Goto} 30 ~~{\tt //}(Just after the for-loop)\\
\end{tabular} \\                    %Fin tableau 1
\vspace{-16pt}
\end{array}                         %Fin array 1
\right. \\                          %Accolade 1
\hline
\end{array}                         %Fin array 0

&
\Longrightarrow\hspace{-18pt}\Longrightarrow
&

\begin{array}{|ll|}                   %Debut array 0
\hline
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\tt tries=1} \\
Block 1 \\
Block 2 \\
{\bf while} ({\tt cond1} \&\& {\tt tries$\le$3} \&\& {\tt cond2}) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
{\tt tries++} \\
Block 3 \\
Block 4 \\
Block 2 \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf if} ({\tt cond1} \&\& {\tt tries$\le$3}) \\
\end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\hspace{-4pt}
\begin{tabular}{l}
Block 3 \\
Block 5 \\
\end{tabular}
\right. \\
\hspace{4pt}~ &
\hspace{-10pt}
\begin{tabular}{l}
{\bf if} ({\tt cond3}) {\bf break} \\
\end{tabular} \\
\hline
\end{array}                           % Fin array 0
\end{array}
$

\caption{Reshaping of the loop over the intersection points : Fortran to C++.}
\label{blocs}

\end{center}


Now, here is how the coordinates of the intersection points {\em in the bending plane (xOy)} between the V0's straight line and the bachelor's helix (actually, of their projection in the bending plane).

Let's call $\Delta$ the projection of the V0's trajectory, and $\mathcal C$ the circle that is the projection of the bachelor's trajectory. Their equations are :
$$\Delta : y=ax+b \qquad\qquad\qquad {\mathcal C} : (x-x_c)^2+(y-y_c)^2 = R^2$$

Calling $(x_0,y_0)$ a point on the V0's trajectory, and $\overrightarrow{p} = (p_x,p_y,p_z)$ its momentum, we obtain :
$$a = \frac{p_y}{p_x} \qquad\qquad\qquad b = y_0-\frac{p_y}{p_x}x_0$$
Thus :
$$\Delta : y = \frac{p_y}{p_x}(x-x_0)+y_0$$
If we change the variables, with $X=x-x_c$ and $Y=y-y_c$, we have :
$$\Delta : Y = \frac{p_y}{p_x}(X+x_c-x_0)+y_0-y_c \qquad\qquad\qquad {\mathcal C} : X^2+Y^2 = R^2$$

Now, we can search the intersection points. If we call $\delta_x = x_c-x_0$ and $\delta_y = y_c-y_0$, we have to solve this system of equations :
$$
\left\{
\begin{array}{r@{~=~}l}
Y^2 & R^2-X^2 \\
Y^2 & \left(\frac{p_y}{p_x}(X+\delta_x)-\delta_y\right)^2 \\
\end{array}
\right.
$$
which, if we define $\alpha = p_y/p_x$ and $\beta = \alpha\delta_x-\delta_y$, and modify the equations, becomes :
$$
\left\{
\begin{array}{l}
Y = \alpha(X+\delta_x)-\delta_y \\
X^2(\alpha^2+1) + 2\alpha\beta X + \beta^2 - R^2 = 0 \\
\end{array}
\right.
$$
If the condition $R^2(\alpha^2+1) \ge \beta^2$ is true, then we have 2 solutions, that are :
$$
\left\{
\begin{array}{l}
Y = \alpha(X+\delta_x)-\delta_y \\
X = \frac{\alpha\beta\pm\sqrt{R^2(\alpha^2+1)-\beta^2}}{\alpha^2+1} \\
\end{array}
\right.
$$











{\sc Fig}. \ref{XiAlgoMieux} shows...


\begin{center}

$
\begin{array}{|ll|}
\hline
\hspace{4pt}~ &
\hspace{-10pt} \begin{tabular}{l} {\bf Loop} over V0 vertices \\ \end{tabular} \\
\hspace{4pt}~ &
\left \lfloor
\begin{array}{l}
\hspace{-10pt} \begin{tabular}{l} Apply cuts on the V0 and V0 daughters \\ {\bf Loop} over global tracks \\ \end{tabular} \\
\left \lfloor
\begin{tabular}{l}
{\bf If} {\em track has wrong charge} : next \\
{\bf If} {\em track already used in the V0} : next \\
Find {\sc dca} between V0's straight line and track's helix \\
Apply cuts \\
{\bf If} {\em good candidate} : store \\
\end{tabular}
\right. \\
\vspace{-12pt}
\end{array}
\right. \\
\hline
\end{array}
$

\caption{Algorithm of the XiFinder.}
\label{XiAlgoMieux}

\end{center}




\vspace{1cm}

\section{Tests}

Blabla.


%Essai avec Dav' de mettre une equation numerotee a gauche : pas moyen !! On dirait qu'on est obliges d'utiliser eqnaray pour numeroter une equation, et eqnarray centre systematiquement, quoi qu'on lui fasse. On ne peut meme pas l'utiliser dans un tableau ni dans une array. Pas plus que l'environnement equationarray (package eqnarray). La FAQ parle de la commande \lefteqn qui s'utilise avec eqnarray, mais sans expliquer comment elle marche. En mettant fleqn dans les options de documentclass, ca marche mais ca le fait pour toutes les equations du document (meme si on utilie \mathindent comme {\parindent blabla}).
%%$\begin{array}{cc}
%%a & b \\
%%c & d \\
%%\end{array}$
%%
%%
%%\begin{eqnarray}
%%a=b
%%\end{eqnarray}
%%
%%{%\mathindent=1cm
%%
%%
%%
%%\begin{eqnarray}
%%a=b
%%\end{eqnarray}
%%
%%}
%%
%%
%%\begin{eqnarray}
%%a=b
%%\end{eqnarray}
%%
%%
%%\begin{flushleft}
%%$\begin{array}{c}
%%x=y
%%\end{array}$
%%\end{flushleft}
%%
%%Ici c'est moi.
%%
%%\lefteqn{
%%\begin{eqnarray}
%%a = b
%%\end{eqnarray}}
%
%\begin{eqnarray}
%x=y
%\end{eqnarray}
%
%\hspace{50pt}
%\begin{eqnarray}
%a=b
%\end{eqnarray}
%
%
%%\begin{flushleft}
%%\hspace{50pt}
%%\begin{alignat}{1}
%%a = b \\
%%c = d
%%\end{alignat}
%%\end{flushleft}
%
%%$\begin{array}{l}
%%\begin{array}{c}
%%$$x=y$$
%%\end{array} \\ 
%%\begin{array}{c}
%%q=y
%%\end{array}
%%
%%\end{array}$
%
%
%\parbox{2cm}{
%\begin{eqnarray}
%%x = y \hfill a \\
%x = y \hspace{12cm} ~
%\end{eqnarray}
%}









\end{document}







